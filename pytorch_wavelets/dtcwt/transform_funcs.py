'''This file was automatically generated by running transform_templates.py'''
import torch
from torch.autograd import Function
from pytorch_wavelets.dtcwt.lowlevel import colfilter, rowfilter
from pytorch_wavelets.dtcwt.lowlevel import coldfilt, rowdfilt
from pytorch_wavelets.dtcwt.lowlevel import colifilt, rowifilt, q2c, c2q

class ifm1(Function):

    @staticmethod
    def forward(ctx, yl, yh1, g0o, g1o, g0a, g0b, g1a, g1b, o_dim, ri_dim):
        ctx.save_for_backward(g0o, g1o, g0a, g0b, g1a, g1b)
        ctx.o_dim = (o_dim % 6)
        ctx.ri_dim = (ri_dim % 6)
        if ctx.o_dim < ctx.ri_dim:
            ctx.ri_dim -= 1
        # Get the height and width dimensions
        if ctx.o_dim >= 3 and ctx.ri_dim >= 3:
            ctx.h_dim = 2
        elif ctx.o_dim >= 4 or ctx.ri_dim >= 4:
            ctx.h_dim = 3
        else:
            ctx.h_dim = 4
        if ctx.o_dim >= 4 and ctx.ri_dim >= 4:
            ctx.w_dim = 3
        elif ctx.o_dim >=4 or ctx.ri_dim >= 4:
            ctx.w_dim = 4
        else:
            ctx.w_dim = 5
        ll = yl
        # Level 1 inverse with biorthogonal synthesis filters
        if yh1 is not None and yh1.shape != torch.Size([0]):
            dev = yh1.device
            deg15, deg165 = torch.unbind(torch.index_select(
                yh1, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
            deg45, deg135 = torch.unbind(torch.index_select(
                yh1, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
            deg75, deg105 = torch.unbind(torch.index_select(
                yh1, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
            lh = c2q(deg15, deg165, ctx.ri_dim)
            hl = c2q(deg75, deg105, ctx.ri_dim)
            hh = c2q(deg45, deg135, ctx.ri_dim)
            Hi = colfilter(hh, g1o) + colfilter(hl, g0o)
            if ll is not None and ll.shape != torch.Size([0]):
                Lo = colfilter(lh, g1o) + colfilter(ll, g0o)
            else:
                Lo = colfilter(lh, g1o)
            y = rowfilter(Hi, g1o) + rowfilter(Lo, g0o)
        else:
            y = rowfilter(colfilter(ll, g0o), g0o)

        return y

    @staticmethod
    def backward(ctx, grad_y):
        g0o, g1o, g0a, g0b, g1a, g1b = ctx.saved_tensors
        grad_yl = None
        grad_yh1 = None

        # Use the special properties of the filters to get the time reverse
        g0o_t = g0o
        g1o_t = g1o
        g0a_t = g0b
        g0b_t = g0a
        g1a_t = g1b
        g1b_t = g1a

        if True in ctx.needs_input_grad:
            # Level 1 inverse gradient - same as fwd transform
            # with time reverse biorthogonal synthesis filters
            Lo = rowfilter(grad_y, g0o_t)
            LoLo = colfilter(Lo, g0o_t)
            if ctx.needs_input_grad[1]:
                Hi = rowfilter(grad_y, g1o_t)
                LoHi = colfilter(Lo, g1o_t)
                HiLo = colfilter(Hi, g0o_t)
                HiHi = colfilter(Hi, g1o_t)
                deg15, deg165 = q2c(LoHi, ctx.ri_dim)
                deg45, deg135 = q2c(HiHi, ctx.ri_dim)
                deg75, deg105 = q2c(HiLo, ctx.ri_dim)
                grad_yh1 = torch.stack(
                    [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)

            if ctx.needs_input_grad[0]:
                grad_yl = LoLo

        return (grad_yl, grad_yh1) + (None,) * 8


class xfm1scale(Function):

    @staticmethod
    def forward(ctx, input, h0o, h1o, h0a, h0b, h1a, h1b, skip_hps, include_scale, o_dim, ri_dim):
        ctx.save_for_backward(h0o, h1o, h0a, h0b, h1a, h1b)
        ctx.o_dim = (o_dim % 6)
        ctx.ri_dim = (ri_dim % 6)
        if ctx.o_dim < ctx.ri_dim:
            ctx.ri_dim -= 1
        if ctx.o_dim >= 3 and ctx.ri_dim >= 3:
            ctx.h_dim = 2
        elif ctx.o_dim >= 4 or ctx.ri_dim >= 4:
            ctx.h_dim = 3
        else:
            ctx.h_dim = 4
        if ctx.o_dim >= 4 and ctx.ri_dim >= 4:
            ctx.w_dim = 3
        elif ctx.o_dim >=4 or ctx.ri_dim >= 4:
            ctx.w_dim = 4
        else:
            ctx.w_dim = 5

        ctx.in_shape = input.shape
        ctx.skip_hps = skip_hps
        ctx.include_scale = include_scale
        ctx.extra_rows = 0
        ctx.extra_cols = 0
        batch, ch, r, c = input.shape

        # If the row/col count of X is not divisible by 2 then we need to
        # extend X
        if r % 2 != 0:
            input = torch.cat((input, input[:,:,-1:]), dim=2)
            ctx.extra_rows = 1
        if c % 2 != 0:
            input = torch.cat((input, input[:,:,:,-1:]), dim=3)
            ctx.extra_cols = 1

        # Level 1 forward (biorthogonal analysis filters)
        Lo = rowfilter(input, h0o)
        if not ctx.skip_hps[0]:
            Hi = rowfilter(input, h1o)
            LoHi = colfilter(Lo, h1o)
            HiLo = colfilter(Hi, h0o)
            HiHi = colfilter(Hi, h1o)
            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh1 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh1 = torch.tensor([], device=input.device)
        LoLo = colfilter(Lo, h0o)
        if ctx.include_scale[0]:
            Ys1 = LoLo
        else:
            Ys1 = torch.tensor([], device=input.device)
        
        Yl = LoLo
        return Ys1, Yh1

    @staticmethod
    def backward(ctx, grad_Ys1, grad_Yh1):
        h0o, h1o, h0a, h0b, h1a, h1b = ctx.saved_tensors
        in_shape = ctx.in_shape
        grad_input = None
        # Use the special properties of the filters to get the time reverse
        h0o_t = h0o
        h1o_t = h1o
        h0a_t = h0b
        h0b_t = h0a
        h1a_t = h1b
        h1b_t = h1a

        if True in ctx.needs_input_grad:
            ll = grad_Ys1
            
            # Level 1 backward (time reversed biorthogonal analysis filters)
            if not ctx.skip_hps[0]:
                dev = grad_Yh1.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh1, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh1, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh1, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colfilter(hh, h1o_t) + colfilter(hl, h0o_t)
                Lo = colfilter(lh, h1o_t) + colfilter(ll, h0o_t)
                grad_input = rowfilter(Hi, h1o_t) + rowfilter(Lo, h0o_t)
            else:
                grad_input = rowfilter(colfilter(ll, h0o_t), h0o_t)
            if ctx.extra_rows:
                grad_input = grad_input[:,:,:-1]
            if ctx.extra_cols:
                grad_input = grad_input[:,:,:,:-1]
            

        return (grad_input,) + (None,) * 10


class xfm1(Function):

    @staticmethod
    def forward(ctx, input, h0o, h1o, h0a, h0b, h1a, h1b, skip_hps, include_scale, o_dim, ri_dim):
        ctx.save_for_backward(h0o, h1o, h0a, h0b, h1a, h1b)
        ctx.o_dim = (o_dim % 6)
        ctx.ri_dim = (ri_dim % 6)
        if ctx.o_dim < ctx.ri_dim:
            ctx.ri_dim -= 1
        if ctx.o_dim >= 3 and ctx.ri_dim >= 3:
            ctx.h_dim = 2
        elif ctx.o_dim >= 4 or ctx.ri_dim >= 4:
            ctx.h_dim = 3
        else:
            ctx.h_dim = 4
        if ctx.o_dim >= 4 and ctx.ri_dim >= 4:
            ctx.w_dim = 3
        elif ctx.o_dim >=4 or ctx.ri_dim >= 4:
            ctx.w_dim = 4
        else:
            ctx.w_dim = 5

        ctx.in_shape = input.shape
        ctx.skip_hps = skip_hps
        ctx.include_scale = include_scale
        ctx.extra_rows = 0
        ctx.extra_cols = 0
        batch, ch, r, c = input.shape

        # If the row/col count of X is not divisible by 2 then we need to
        # extend X
        if r % 2 != 0:
            input = torch.cat((input, input[:,:,-1:]), dim=2)
            ctx.extra_rows = 1
        if c % 2 != 0:
            input = torch.cat((input, input[:,:,:,-1:]), dim=3)
            ctx.extra_cols = 1

        # Level 1 forward (biorthogonal analysis filters)
        Lo = rowfilter(input, h0o)
        if not ctx.skip_hps[0]:
            Hi = rowfilter(input, h1o)
            LoHi = colfilter(Lo, h1o)
            HiLo = colfilter(Hi, h0o)
            HiHi = colfilter(Hi, h1o)
            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh1 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh1 = torch.tensor([], device=input.device)
        LoLo = colfilter(Lo, h0o)
        if ctx.include_scale[0]:
            Ys1 = LoLo
        else:
            Ys1 = torch.tensor([], device=input.device)
        
        Yl = LoLo
        return Yl, Yh1

    @staticmethod
    def backward(ctx, grad_LoLo, grad_Yh1):
        h0o, h1o, h0a, h0b, h1a, h1b = ctx.saved_tensors
        in_shape = ctx.in_shape
        grad_input = None
        # Use the special properties of the filters to get the time reverse
        h0o_t = h0o
        h1o_t = h1o
        h0a_t = h0b
        h0b_t = h0a
        h1a_t = h1b
        h1b_t = h1a

        if True in ctx.needs_input_grad:
            ll = grad_LoLo
            
            # Level 1 backward (time reversed biorthogonal analysis filters)
            if not ctx.skip_hps[0]:
                dev = grad_Yh1.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh1, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh1, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh1, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colfilter(hh, h1o_t) + colfilter(hl, h0o_t)
                Lo = colfilter(lh, h1o_t) + colfilter(ll, h0o_t)
                grad_input = rowfilter(Hi, h1o_t) + rowfilter(Lo, h0o_t)
            else:
                grad_input = rowfilter(colfilter(ll, h0o_t), h0o_t)
            if ctx.extra_rows:
                grad_input = grad_input[:,:,:-1]
            if ctx.extra_cols:
                grad_input = grad_input[:,:,:,:-1]
            

        return (grad_input,) + (None,) * 10


class ifm2(Function):

    @staticmethod
    def forward(ctx, yl, yh1, yh2, g0o, g1o, g0a, g0b, g1a, g1b, o_dim, ri_dim):
        ctx.save_for_backward(g0o, g1o, g0a, g0b, g1a, g1b)
        ctx.o_dim = (o_dim % 6)
        ctx.ri_dim = (ri_dim % 6)
        if ctx.o_dim < ctx.ri_dim:
            ctx.ri_dim -= 1
        # Get the height and width dimensions
        if ctx.o_dim >= 3 and ctx.ri_dim >= 3:
            ctx.h_dim = 2
        elif ctx.o_dim >= 4 or ctx.ri_dim >= 4:
            ctx.h_dim = 3
        else:
            ctx.h_dim = 4
        if ctx.o_dim >= 4 and ctx.ri_dim >= 4:
            ctx.w_dim = 3
        elif ctx.o_dim >=4 or ctx.ri_dim >= 4:
            ctx.w_dim = 4
        else:
            ctx.w_dim = 5
        ll = yl
        # Level 2 inverse transform with quater shift synthesis filters
        if yh2 is not None and yh2.shape != torch.Size([0]):
            dev = yh2.device
            deg15, deg165 = torch.unbind(torch.index_select(
                yh2, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
            deg45, deg135 = torch.unbind(torch.index_select(
                yh2, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
            deg75, deg105 = torch.unbind(torch.index_select(
                yh2, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
            lh = c2q(deg15, deg165, ctx.ri_dim)
            hl = c2q(deg75, deg105, ctx.ri_dim)
            hh = c2q(deg45, deg135, ctx.ri_dim)
            Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
            if ll is not None and ll.shape != torch.Size([0]):
                Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
            else:
                Lo = colifilt(lh, g1b, g1a, True)
            ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        else:
            ll = rowifilt(colifilt(ll, g0b, g0a), g0b, g0a)
        
        # Level 1 inverse with biorthogonal synthesis filters
        if yh1 is not None and yh1.shape != torch.Size([0]):
            r, c = ll.shape[2:]
            r1, c1 = yh1.shape[ctx.h_dim], yh1.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]
            dev = yh1.device
            deg15, deg165 = torch.unbind(torch.index_select(
                yh1, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
            deg45, deg135 = torch.unbind(torch.index_select(
                yh1, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
            deg75, deg105 = torch.unbind(torch.index_select(
                yh1, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
            lh = c2q(deg15, deg165, ctx.ri_dim)
            hl = c2q(deg75, deg105, ctx.ri_dim)
            hh = c2q(deg45, deg135, ctx.ri_dim)
            Hi = colfilter(hh, g1o) + colfilter(hl, g0o)
            if ll is not None and ll.shape != torch.Size([0]):
                Lo = colfilter(lh, g1o) + colfilter(ll, g0o)
            else:
                Lo = colfilter(lh, g1o)
            y = rowfilter(Hi, g1o) + rowfilter(Lo, g0o)
        else:
            y = rowfilter(colfilter(ll, g0o), g0o)

        return y

    @staticmethod
    def backward(ctx, grad_y):
        g0o, g1o, g0a, g0b, g1a, g1b = ctx.saved_tensors
        grad_yl = None
        grad_yh1 = None
        grad_yh2 = None

        # Use the special properties of the filters to get the time reverse
        g0o_t = g0o
        g1o_t = g1o
        g0a_t = g0b
        g0b_t = g0a
        g1a_t = g1b
        g1b_t = g1a

        if True in ctx.needs_input_grad:
            # Level 1 inverse gradient - same as fwd transform
            # with time reverse biorthogonal synthesis filters
            Lo = rowfilter(grad_y, g0o_t)
            LoLo = colfilter(Lo, g0o_t)
            if ctx.needs_input_grad[1]:
                Hi = rowfilter(grad_y, g1o_t)
                LoHi = colfilter(Lo, g1o_t)
                HiLo = colfilter(Hi, g0o_t)
                HiHi = colfilter(Hi, g1o_t)
                deg15, deg165 = q2c(LoHi, ctx.ri_dim)
                deg45, deg135 = q2c(HiHi, ctx.ri_dim)
                deg75, deg105 = q2c(HiLo, ctx.ri_dim)
                grad_yh1 = torch.stack(
                    [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)

            # Level 2 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            if ctx.needs_input_grad[2]:
                Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
                LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
                HiLo = coldfilt(Hi, g0b_t, g0a_t)
                HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

                deg15, deg165 = q2c(LoHi, ctx.ri_dim)
                deg45, deg135 = q2c(HiHi, ctx.ri_dim)
                deg75, deg105 = q2c(HiLo, ctx.ri_dim)
                grad_yh2 = torch.stack(
                    [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            if ctx.needs_input_grad[0]:
                grad_yl = LoLo

        return (grad_yl, grad_yh1, grad_yh2) + (None,) * 8


class xfm2scale(Function):

    @staticmethod
    def forward(ctx, input, h0o, h1o, h0a, h0b, h1a, h1b, skip_hps, include_scale, o_dim, ri_dim):
        ctx.save_for_backward(h0o, h1o, h0a, h0b, h1a, h1b)
        ctx.o_dim = (o_dim % 6)
        ctx.ri_dim = (ri_dim % 6)
        if ctx.o_dim < ctx.ri_dim:
            ctx.ri_dim -= 1
        if ctx.o_dim >= 3 and ctx.ri_dim >= 3:
            ctx.h_dim = 2
        elif ctx.o_dim >= 4 or ctx.ri_dim >= 4:
            ctx.h_dim = 3
        else:
            ctx.h_dim = 4
        if ctx.o_dim >= 4 and ctx.ri_dim >= 4:
            ctx.w_dim = 3
        elif ctx.o_dim >=4 or ctx.ri_dim >= 4:
            ctx.w_dim = 4
        else:
            ctx.w_dim = 5

        ctx.in_shape = input.shape
        ctx.skip_hps = skip_hps
        ctx.include_scale = include_scale
        ctx.extra_rows = 0
        ctx.extra_cols = 0
        batch, ch, r, c = input.shape

        # If the row/col count of X is not divisible by 2 then we need to
        # extend X
        if r % 2 != 0:
            input = torch.cat((input, input[:,:,-1:]), dim=2)
            ctx.extra_rows = 1
        if c % 2 != 0:
            input = torch.cat((input, input[:,:,:,-1:]), dim=3)
            ctx.extra_cols = 1

        # Level 1 forward (biorthogonal analysis filters)
        Lo = rowfilter(input, h0o)
        if not ctx.skip_hps[0]:
            Hi = rowfilter(input, h1o)
            LoHi = colfilter(Lo, h1o)
            HiLo = colfilter(Hi, h0o)
            HiHi = colfilter(Hi, h1o)
            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh1 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh1 = torch.tensor([], device=input.device)
        LoLo = colfilter(Lo, h0o)
        if ctx.include_scale[0]:
            Ys1 = LoLo
        else:
            Ys1 = torch.tensor([], device=input.device)
        
        # Level 2 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        if not ctx.skip_hps[1]:
            Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
            LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
            HiLo = coldfilt(Hi, h0b, h0a)
            HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh2 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh2 = torch.tensor([], device=input.device)
        LoLo = coldfilt(Lo, h0b, h0a)
        if ctx.include_scale[1]:
            Ys2 = LoLo
        else:
            Ys2 = torch.tensor([], device=input.device)

        Yl = LoLo
        return Ys1, Ys2, Yh1, Yh2

    @staticmethod
    def backward(ctx, grad_Ys1, grad_Ys2, grad_Yh1, grad_Yh2):
        h0o, h1o, h0a, h0b, h1a, h1b = ctx.saved_tensors
        in_shape = ctx.in_shape
        grad_input = None
        # Use the special properties of the filters to get the time reverse
        h0o_t = h0o
        h1o_t = h1o
        h0a_t = h0b
        h0b_t = h0a
        h1a_t = h1b
        h1b_t = h1a

        if True in ctx.needs_input_grad:
            ll = grad_Ys2
            
            # Level 2 backward (time reversed quater shift analysis filters)
            if not ctx.skip_hps[1]:
                dev = grad_Yh2.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh2, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh2, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh2, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
                Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
                ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            else:
                ll = rowifilt(colifilt(Lo, h0b_t, h0a_t), h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh1.shape[ctx.h_dim], grad_Yh1.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]
            if ctx.include_scale[0]:
                ll = (ll + grad_Ys1)/2

            # Level 1 backward (time reversed biorthogonal analysis filters)
            if not ctx.skip_hps[0]:
                dev = grad_Yh1.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh1, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh1, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh1, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colfilter(hh, h1o_t) + colfilter(hl, h0o_t)
                Lo = colfilter(lh, h1o_t) + colfilter(ll, h0o_t)
                grad_input = rowfilter(Hi, h1o_t) + rowfilter(Lo, h0o_t)
            else:
                grad_input = rowfilter(colfilter(ll, h0o_t), h0o_t)
            if ctx.extra_rows:
                grad_input = grad_input[:,:,:-1]
            if ctx.extra_cols:
                grad_input = grad_input[:,:,:,:-1]
            

        return (grad_input,) + (None,) * 10


class xfm2(Function):

    @staticmethod
    def forward(ctx, input, h0o, h1o, h0a, h0b, h1a, h1b, skip_hps, include_scale, o_dim, ri_dim):
        ctx.save_for_backward(h0o, h1o, h0a, h0b, h1a, h1b)
        ctx.o_dim = (o_dim % 6)
        ctx.ri_dim = (ri_dim % 6)
        if ctx.o_dim < ctx.ri_dim:
            ctx.ri_dim -= 1
        if ctx.o_dim >= 3 and ctx.ri_dim >= 3:
            ctx.h_dim = 2
        elif ctx.o_dim >= 4 or ctx.ri_dim >= 4:
            ctx.h_dim = 3
        else:
            ctx.h_dim = 4
        if ctx.o_dim >= 4 and ctx.ri_dim >= 4:
            ctx.w_dim = 3
        elif ctx.o_dim >=4 or ctx.ri_dim >= 4:
            ctx.w_dim = 4
        else:
            ctx.w_dim = 5

        ctx.in_shape = input.shape
        ctx.skip_hps = skip_hps
        ctx.include_scale = include_scale
        ctx.extra_rows = 0
        ctx.extra_cols = 0
        batch, ch, r, c = input.shape

        # If the row/col count of X is not divisible by 2 then we need to
        # extend X
        if r % 2 != 0:
            input = torch.cat((input, input[:,:,-1:]), dim=2)
            ctx.extra_rows = 1
        if c % 2 != 0:
            input = torch.cat((input, input[:,:,:,-1:]), dim=3)
            ctx.extra_cols = 1

        # Level 1 forward (biorthogonal analysis filters)
        Lo = rowfilter(input, h0o)
        if not ctx.skip_hps[0]:
            Hi = rowfilter(input, h1o)
            LoHi = colfilter(Lo, h1o)
            HiLo = colfilter(Hi, h0o)
            HiHi = colfilter(Hi, h1o)
            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh1 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh1 = torch.tensor([], device=input.device)
        LoLo = colfilter(Lo, h0o)
        if ctx.include_scale[0]:
            Ys1 = LoLo
        else:
            Ys1 = torch.tensor([], device=input.device)
        
        # Level 2 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        if not ctx.skip_hps[1]:
            Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
            LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
            HiLo = coldfilt(Hi, h0b, h0a)
            HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh2 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh2 = torch.tensor([], device=input.device)
        LoLo = coldfilt(Lo, h0b, h0a)
        if ctx.include_scale[1]:
            Ys2 = LoLo
        else:
            Ys2 = torch.tensor([], device=input.device)

        Yl = LoLo
        return Yl, Yh1, Yh2

    @staticmethod
    def backward(ctx, grad_LoLo, grad_Yh1, grad_Yh2):
        h0o, h1o, h0a, h0b, h1a, h1b = ctx.saved_tensors
        in_shape = ctx.in_shape
        grad_input = None
        # Use the special properties of the filters to get the time reverse
        h0o_t = h0o
        h1o_t = h1o
        h0a_t = h0b
        h0b_t = h0a
        h1a_t = h1b
        h1b_t = h1a

        if True in ctx.needs_input_grad:
            ll = grad_LoLo
            
            # Level 2 backward (time reversed quater shift analysis filters)
            if not ctx.skip_hps[1]:
                dev = grad_Yh2.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh2, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh2, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh2, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
                Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
                ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            else:
                ll = rowifilt(colifilt(Lo, h0b_t, h0a_t), h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh1.shape[ctx.h_dim], grad_Yh1.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 1 backward (time reversed biorthogonal analysis filters)
            if not ctx.skip_hps[0]:
                dev = grad_Yh1.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh1, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh1, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh1, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colfilter(hh, h1o_t) + colfilter(hl, h0o_t)
                Lo = colfilter(lh, h1o_t) + colfilter(ll, h0o_t)
                grad_input = rowfilter(Hi, h1o_t) + rowfilter(Lo, h0o_t)
            else:
                grad_input = rowfilter(colfilter(ll, h0o_t), h0o_t)
            if ctx.extra_rows:
                grad_input = grad_input[:,:,:-1]
            if ctx.extra_cols:
                grad_input = grad_input[:,:,:,:-1]
            

        return (grad_input,) + (None,) * 10


class ifm3(Function):

    @staticmethod
    def forward(ctx, yl, yh1, yh2, yh3, g0o, g1o, g0a, g0b, g1a, g1b, o_dim, ri_dim):
        ctx.save_for_backward(g0o, g1o, g0a, g0b, g1a, g1b)
        ctx.o_dim = (o_dim % 6)
        ctx.ri_dim = (ri_dim % 6)
        if ctx.o_dim < ctx.ri_dim:
            ctx.ri_dim -= 1
        # Get the height and width dimensions
        if ctx.o_dim >= 3 and ctx.ri_dim >= 3:
            ctx.h_dim = 2
        elif ctx.o_dim >= 4 or ctx.ri_dim >= 4:
            ctx.h_dim = 3
        else:
            ctx.h_dim = 4
        if ctx.o_dim >= 4 and ctx.ri_dim >= 4:
            ctx.w_dim = 3
        elif ctx.o_dim >=4 or ctx.ri_dim >= 4:
            ctx.w_dim = 4
        else:
            ctx.w_dim = 5
        ll = yl
        # Level 3 inverse transform with quater shift synthesis filters
        if yh3 is not None and yh3.shape != torch.Size([0]):
            dev = yh3.device
            deg15, deg165 = torch.unbind(torch.index_select(
                yh3, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
            deg45, deg135 = torch.unbind(torch.index_select(
                yh3, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
            deg75, deg105 = torch.unbind(torch.index_select(
                yh3, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
            lh = c2q(deg15, deg165, ctx.ri_dim)
            hl = c2q(deg75, deg105, ctx.ri_dim)
            hh = c2q(deg45, deg135, ctx.ri_dim)
            Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
            if ll is not None and ll.shape != torch.Size([0]):
                Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
            else:
                Lo = colifilt(lh, g1b, g1a, True)
            ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        else:
            ll = rowifilt(colifilt(ll, g0b, g0a), g0b, g0a)
        

        # Level 2 inverse transform with quater shift synthesis filters
        if yh2 is not None and yh2.shape != torch.Size([0]):
            r, c = ll.shape[2:]
            r1, c1 = yh2.shape[ctx.h_dim], yh2.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]
            dev = yh2.device
            deg15, deg165 = torch.unbind(torch.index_select(
                yh2, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
            deg45, deg135 = torch.unbind(torch.index_select(
                yh2, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
            deg75, deg105 = torch.unbind(torch.index_select(
                yh2, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
            lh = c2q(deg15, deg165, ctx.ri_dim)
            hl = c2q(deg75, deg105, ctx.ri_dim)
            hh = c2q(deg45, deg135, ctx.ri_dim)
            Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
            if ll is not None and ll.shape != torch.Size([0]):
                Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
            else:
                Lo = colifilt(lh, g1b, g1a, True)
            ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        else:
            ll = rowifilt(colifilt(ll, g0b, g0a), g0b, g0a)
        
        # Level 1 inverse with biorthogonal synthesis filters
        if yh1 is not None and yh1.shape != torch.Size([0]):
            r, c = ll.shape[2:]
            r1, c1 = yh1.shape[ctx.h_dim], yh1.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]
            dev = yh1.device
            deg15, deg165 = torch.unbind(torch.index_select(
                yh1, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
            deg45, deg135 = torch.unbind(torch.index_select(
                yh1, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
            deg75, deg105 = torch.unbind(torch.index_select(
                yh1, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
            lh = c2q(deg15, deg165, ctx.ri_dim)
            hl = c2q(deg75, deg105, ctx.ri_dim)
            hh = c2q(deg45, deg135, ctx.ri_dim)
            Hi = colfilter(hh, g1o) + colfilter(hl, g0o)
            if ll is not None and ll.shape != torch.Size([0]):
                Lo = colfilter(lh, g1o) + colfilter(ll, g0o)
            else:
                Lo = colfilter(lh, g1o)
            y = rowfilter(Hi, g1o) + rowfilter(Lo, g0o)
        else:
            y = rowfilter(colfilter(ll, g0o), g0o)

        return y

    @staticmethod
    def backward(ctx, grad_y):
        g0o, g1o, g0a, g0b, g1a, g1b = ctx.saved_tensors
        grad_yl = None
        grad_yh1 = None
        grad_yh2 = None
        grad_yh3 = None

        # Use the special properties of the filters to get the time reverse
        g0o_t = g0o
        g1o_t = g1o
        g0a_t = g0b
        g0b_t = g0a
        g1a_t = g1b
        g1b_t = g1a

        if True in ctx.needs_input_grad:
            # Level 1 inverse gradient - same as fwd transform
            # with time reverse biorthogonal synthesis filters
            Lo = rowfilter(grad_y, g0o_t)
            LoLo = colfilter(Lo, g0o_t)
            if ctx.needs_input_grad[1]:
                Hi = rowfilter(grad_y, g1o_t)
                LoHi = colfilter(Lo, g1o_t)
                HiLo = colfilter(Hi, g0o_t)
                HiHi = colfilter(Hi, g1o_t)
                deg15, deg165 = q2c(LoHi, ctx.ri_dim)
                deg45, deg135 = q2c(HiHi, ctx.ri_dim)
                deg75, deg105 = q2c(HiLo, ctx.ri_dim)
                grad_yh1 = torch.stack(
                    [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)

            # Level 2 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            if ctx.needs_input_grad[2]:
                Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
                LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
                HiLo = coldfilt(Hi, g0b_t, g0a_t)
                HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

                deg15, deg165 = q2c(LoHi, ctx.ri_dim)
                deg45, deg135 = q2c(HiHi, ctx.ri_dim)
                deg75, deg105 = q2c(HiLo, ctx.ri_dim)
                grad_yh2 = torch.stack(
                    [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            # Level 3 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            if ctx.needs_input_grad[3]:
                Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
                LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
                HiLo = coldfilt(Hi, g0b_t, g0a_t)
                HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

                deg15, deg165 = q2c(LoHi, ctx.ri_dim)
                deg45, deg135 = q2c(HiHi, ctx.ri_dim)
                deg75, deg105 = q2c(HiLo, ctx.ri_dim)
                grad_yh3 = torch.stack(
                    [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            if ctx.needs_input_grad[0]:
                grad_yl = LoLo

        return (grad_yl, grad_yh1, grad_yh2, grad_yh3) + (None,) * 8


class xfm3scale(Function):

    @staticmethod
    def forward(ctx, input, h0o, h1o, h0a, h0b, h1a, h1b, skip_hps, include_scale, o_dim, ri_dim):
        ctx.save_for_backward(h0o, h1o, h0a, h0b, h1a, h1b)
        ctx.o_dim = (o_dim % 6)
        ctx.ri_dim = (ri_dim % 6)
        if ctx.o_dim < ctx.ri_dim:
            ctx.ri_dim -= 1
        if ctx.o_dim >= 3 and ctx.ri_dim >= 3:
            ctx.h_dim = 2
        elif ctx.o_dim >= 4 or ctx.ri_dim >= 4:
            ctx.h_dim = 3
        else:
            ctx.h_dim = 4
        if ctx.o_dim >= 4 and ctx.ri_dim >= 4:
            ctx.w_dim = 3
        elif ctx.o_dim >=4 or ctx.ri_dim >= 4:
            ctx.w_dim = 4
        else:
            ctx.w_dim = 5

        ctx.in_shape = input.shape
        ctx.skip_hps = skip_hps
        ctx.include_scale = include_scale
        ctx.extra_rows = 0
        ctx.extra_cols = 0
        batch, ch, r, c = input.shape

        # If the row/col count of X is not divisible by 2 then we need to
        # extend X
        if r % 2 != 0:
            input = torch.cat((input, input[:,:,-1:]), dim=2)
            ctx.extra_rows = 1
        if c % 2 != 0:
            input = torch.cat((input, input[:,:,:,-1:]), dim=3)
            ctx.extra_cols = 1

        # Level 1 forward (biorthogonal analysis filters)
        Lo = rowfilter(input, h0o)
        if not ctx.skip_hps[0]:
            Hi = rowfilter(input, h1o)
            LoHi = colfilter(Lo, h1o)
            HiLo = colfilter(Hi, h0o)
            HiHi = colfilter(Hi, h1o)
            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh1 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh1 = torch.tensor([], device=input.device)
        LoLo = colfilter(Lo, h0o)
        if ctx.include_scale[0]:
            Ys1 = LoLo
        else:
            Ys1 = torch.tensor([], device=input.device)
        
        # Level 2 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        if not ctx.skip_hps[1]:
            Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
            LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
            HiLo = coldfilt(Hi, h0b, h0a)
            HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh2 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh2 = torch.tensor([], device=input.device)
        LoLo = coldfilt(Lo, h0b, h0a)
        if ctx.include_scale[1]:
            Ys2 = LoLo
        else:
            Ys2 = torch.tensor([], device=input.device)

        # Level 3 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        if not ctx.skip_hps[2]:
            Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
            LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
            HiLo = coldfilt(Hi, h0b, h0a)
            HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh3 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh3 = torch.tensor([], device=input.device)
        LoLo = coldfilt(Lo, h0b, h0a)
        if ctx.include_scale[2]:
            Ys3 = LoLo
        else:
            Ys3 = torch.tensor([], device=input.device)

        Yl = LoLo
        return Ys1, Ys2, Ys3, Yh1, Yh2, Yh3

    @staticmethod
    def backward(ctx, grad_Ys1, grad_Ys2, grad_Ys3, grad_Yh1, grad_Yh2, grad_Yh3):
        h0o, h1o, h0a, h0b, h1a, h1b = ctx.saved_tensors
        in_shape = ctx.in_shape
        grad_input = None
        # Use the special properties of the filters to get the time reverse
        h0o_t = h0o
        h1o_t = h1o
        h0a_t = h0b
        h0b_t = h0a
        h1a_t = h1b
        h1b_t = h1a

        if True in ctx.needs_input_grad:
            ll = grad_Ys3
            
            # Level 3 backward (time reversed quater shift analysis filters)
            if not ctx.skip_hps[2]:
                dev = grad_Yh3.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh3, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh3, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh3, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
                Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
                ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            else:
                ll = rowifilt(colifilt(Lo, h0b_t, h0a_t), h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh2.shape[ctx.h_dim], grad_Yh2.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]
            if ctx.include_scale[1]:
                ll = (ll + grad_Ys2)/2

            # Level 2 backward (time reversed quater shift analysis filters)
            if not ctx.skip_hps[1]:
                dev = grad_Yh2.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh2, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh2, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh2, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
                Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
                ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            else:
                ll = rowifilt(colifilt(Lo, h0b_t, h0a_t), h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh1.shape[ctx.h_dim], grad_Yh1.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]
            if ctx.include_scale[0]:
                ll = (ll + grad_Ys1)/2

            # Level 1 backward (time reversed biorthogonal analysis filters)
            if not ctx.skip_hps[0]:
                dev = grad_Yh1.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh1, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh1, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh1, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colfilter(hh, h1o_t) + colfilter(hl, h0o_t)
                Lo = colfilter(lh, h1o_t) + colfilter(ll, h0o_t)
                grad_input = rowfilter(Hi, h1o_t) + rowfilter(Lo, h0o_t)
            else:
                grad_input = rowfilter(colfilter(ll, h0o_t), h0o_t)
            if ctx.extra_rows:
                grad_input = grad_input[:,:,:-1]
            if ctx.extra_cols:
                grad_input = grad_input[:,:,:,:-1]
            

        return (grad_input,) + (None,) * 10


class xfm3(Function):

    @staticmethod
    def forward(ctx, input, h0o, h1o, h0a, h0b, h1a, h1b, skip_hps, include_scale, o_dim, ri_dim):
        ctx.save_for_backward(h0o, h1o, h0a, h0b, h1a, h1b)
        ctx.o_dim = (o_dim % 6)
        ctx.ri_dim = (ri_dim % 6)
        if ctx.o_dim < ctx.ri_dim:
            ctx.ri_dim -= 1
        if ctx.o_dim >= 3 and ctx.ri_dim >= 3:
            ctx.h_dim = 2
        elif ctx.o_dim >= 4 or ctx.ri_dim >= 4:
            ctx.h_dim = 3
        else:
            ctx.h_dim = 4
        if ctx.o_dim >= 4 and ctx.ri_dim >= 4:
            ctx.w_dim = 3
        elif ctx.o_dim >=4 or ctx.ri_dim >= 4:
            ctx.w_dim = 4
        else:
            ctx.w_dim = 5

        ctx.in_shape = input.shape
        ctx.skip_hps = skip_hps
        ctx.include_scale = include_scale
        ctx.extra_rows = 0
        ctx.extra_cols = 0
        batch, ch, r, c = input.shape

        # If the row/col count of X is not divisible by 2 then we need to
        # extend X
        if r % 2 != 0:
            input = torch.cat((input, input[:,:,-1:]), dim=2)
            ctx.extra_rows = 1
        if c % 2 != 0:
            input = torch.cat((input, input[:,:,:,-1:]), dim=3)
            ctx.extra_cols = 1

        # Level 1 forward (biorthogonal analysis filters)
        Lo = rowfilter(input, h0o)
        if not ctx.skip_hps[0]:
            Hi = rowfilter(input, h1o)
            LoHi = colfilter(Lo, h1o)
            HiLo = colfilter(Hi, h0o)
            HiHi = colfilter(Hi, h1o)
            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh1 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh1 = torch.tensor([], device=input.device)
        LoLo = colfilter(Lo, h0o)
        if ctx.include_scale[0]:
            Ys1 = LoLo
        else:
            Ys1 = torch.tensor([], device=input.device)
        
        # Level 2 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        if not ctx.skip_hps[1]:
            Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
            LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
            HiLo = coldfilt(Hi, h0b, h0a)
            HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh2 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh2 = torch.tensor([], device=input.device)
        LoLo = coldfilt(Lo, h0b, h0a)
        if ctx.include_scale[1]:
            Ys2 = LoLo
        else:
            Ys2 = torch.tensor([], device=input.device)

        # Level 3 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        if not ctx.skip_hps[2]:
            Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
            LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
            HiLo = coldfilt(Hi, h0b, h0a)
            HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh3 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh3 = torch.tensor([], device=input.device)
        LoLo = coldfilt(Lo, h0b, h0a)
        if ctx.include_scale[2]:
            Ys3 = LoLo
        else:
            Ys3 = torch.tensor([], device=input.device)

        Yl = LoLo
        return Yl, Yh1, Yh2, Yh3

    @staticmethod
    def backward(ctx, grad_LoLo, grad_Yh1, grad_Yh2, grad_Yh3):
        h0o, h1o, h0a, h0b, h1a, h1b = ctx.saved_tensors
        in_shape = ctx.in_shape
        grad_input = None
        # Use the special properties of the filters to get the time reverse
        h0o_t = h0o
        h1o_t = h1o
        h0a_t = h0b
        h0b_t = h0a
        h1a_t = h1b
        h1b_t = h1a

        if True in ctx.needs_input_grad:
            ll = grad_LoLo
            
            # Level 3 backward (time reversed quater shift analysis filters)
            if not ctx.skip_hps[2]:
                dev = grad_Yh3.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh3, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh3, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh3, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
                Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
                ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            else:
                ll = rowifilt(colifilt(Lo, h0b_t, h0a_t), h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh2.shape[ctx.h_dim], grad_Yh2.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 2 backward (time reversed quater shift analysis filters)
            if not ctx.skip_hps[1]:
                dev = grad_Yh2.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh2, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh2, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh2, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
                Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
                ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            else:
                ll = rowifilt(colifilt(Lo, h0b_t, h0a_t), h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh1.shape[ctx.h_dim], grad_Yh1.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 1 backward (time reversed biorthogonal analysis filters)
            if not ctx.skip_hps[0]:
                dev = grad_Yh1.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh1, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh1, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh1, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colfilter(hh, h1o_t) + colfilter(hl, h0o_t)
                Lo = colfilter(lh, h1o_t) + colfilter(ll, h0o_t)
                grad_input = rowfilter(Hi, h1o_t) + rowfilter(Lo, h0o_t)
            else:
                grad_input = rowfilter(colfilter(ll, h0o_t), h0o_t)
            if ctx.extra_rows:
                grad_input = grad_input[:,:,:-1]
            if ctx.extra_cols:
                grad_input = grad_input[:,:,:,:-1]
            

        return (grad_input,) + (None,) * 10


class ifm4(Function):

    @staticmethod
    def forward(ctx, yl, yh1, yh2, yh3, yh4, g0o, g1o, g0a, g0b, g1a, g1b, o_dim, ri_dim):
        ctx.save_for_backward(g0o, g1o, g0a, g0b, g1a, g1b)
        ctx.o_dim = (o_dim % 6)
        ctx.ri_dim = (ri_dim % 6)
        if ctx.o_dim < ctx.ri_dim:
            ctx.ri_dim -= 1
        # Get the height and width dimensions
        if ctx.o_dim >= 3 and ctx.ri_dim >= 3:
            ctx.h_dim = 2
        elif ctx.o_dim >= 4 or ctx.ri_dim >= 4:
            ctx.h_dim = 3
        else:
            ctx.h_dim = 4
        if ctx.o_dim >= 4 and ctx.ri_dim >= 4:
            ctx.w_dim = 3
        elif ctx.o_dim >=4 or ctx.ri_dim >= 4:
            ctx.w_dim = 4
        else:
            ctx.w_dim = 5
        ll = yl
        # Level 4 inverse transform with quater shift synthesis filters
        if yh4 is not None and yh4.shape != torch.Size([0]):
            dev = yh4.device
            deg15, deg165 = torch.unbind(torch.index_select(
                yh4, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
            deg45, deg135 = torch.unbind(torch.index_select(
                yh4, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
            deg75, deg105 = torch.unbind(torch.index_select(
                yh4, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
            lh = c2q(deg15, deg165, ctx.ri_dim)
            hl = c2q(deg75, deg105, ctx.ri_dim)
            hh = c2q(deg45, deg135, ctx.ri_dim)
            Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
            if ll is not None and ll.shape != torch.Size([0]):
                Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
            else:
                Lo = colifilt(lh, g1b, g1a, True)
            ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        else:
            ll = rowifilt(colifilt(ll, g0b, g0a), g0b, g0a)
        

        # Level 3 inverse transform with quater shift synthesis filters
        if yh3 is not None and yh3.shape != torch.Size([0]):
            r, c = ll.shape[2:]
            r1, c1 = yh3.shape[ctx.h_dim], yh3.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]
            dev = yh3.device
            deg15, deg165 = torch.unbind(torch.index_select(
                yh3, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
            deg45, deg135 = torch.unbind(torch.index_select(
                yh3, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
            deg75, deg105 = torch.unbind(torch.index_select(
                yh3, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
            lh = c2q(deg15, deg165, ctx.ri_dim)
            hl = c2q(deg75, deg105, ctx.ri_dim)
            hh = c2q(deg45, deg135, ctx.ri_dim)
            Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
            if ll is not None and ll.shape != torch.Size([0]):
                Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
            else:
                Lo = colifilt(lh, g1b, g1a, True)
            ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        else:
            ll = rowifilt(colifilt(ll, g0b, g0a), g0b, g0a)
        

        # Level 2 inverse transform with quater shift synthesis filters
        if yh2 is not None and yh2.shape != torch.Size([0]):
            r, c = ll.shape[2:]
            r1, c1 = yh2.shape[ctx.h_dim], yh2.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]
            dev = yh2.device
            deg15, deg165 = torch.unbind(torch.index_select(
                yh2, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
            deg45, deg135 = torch.unbind(torch.index_select(
                yh2, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
            deg75, deg105 = torch.unbind(torch.index_select(
                yh2, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
            lh = c2q(deg15, deg165, ctx.ri_dim)
            hl = c2q(deg75, deg105, ctx.ri_dim)
            hh = c2q(deg45, deg135, ctx.ri_dim)
            Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
            if ll is not None and ll.shape != torch.Size([0]):
                Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
            else:
                Lo = colifilt(lh, g1b, g1a, True)
            ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        else:
            ll = rowifilt(colifilt(ll, g0b, g0a), g0b, g0a)
        
        # Level 1 inverse with biorthogonal synthesis filters
        if yh1 is not None and yh1.shape != torch.Size([0]):
            r, c = ll.shape[2:]
            r1, c1 = yh1.shape[ctx.h_dim], yh1.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]
            dev = yh1.device
            deg15, deg165 = torch.unbind(torch.index_select(
                yh1, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
            deg45, deg135 = torch.unbind(torch.index_select(
                yh1, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
            deg75, deg105 = torch.unbind(torch.index_select(
                yh1, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
            lh = c2q(deg15, deg165, ctx.ri_dim)
            hl = c2q(deg75, deg105, ctx.ri_dim)
            hh = c2q(deg45, deg135, ctx.ri_dim)
            Hi = colfilter(hh, g1o) + colfilter(hl, g0o)
            if ll is not None and ll.shape != torch.Size([0]):
                Lo = colfilter(lh, g1o) + colfilter(ll, g0o)
            else:
                Lo = colfilter(lh, g1o)
            y = rowfilter(Hi, g1o) + rowfilter(Lo, g0o)
        else:
            y = rowfilter(colfilter(ll, g0o), g0o)

        return y

    @staticmethod
    def backward(ctx, grad_y):
        g0o, g1o, g0a, g0b, g1a, g1b = ctx.saved_tensors
        grad_yl = None
        grad_yh1 = None
        grad_yh2 = None
        grad_yh3 = None
        grad_yh4 = None

        # Use the special properties of the filters to get the time reverse
        g0o_t = g0o
        g1o_t = g1o
        g0a_t = g0b
        g0b_t = g0a
        g1a_t = g1b
        g1b_t = g1a

        if True in ctx.needs_input_grad:
            # Level 1 inverse gradient - same as fwd transform
            # with time reverse biorthogonal synthesis filters
            Lo = rowfilter(grad_y, g0o_t)
            LoLo = colfilter(Lo, g0o_t)
            if ctx.needs_input_grad[1]:
                Hi = rowfilter(grad_y, g1o_t)
                LoHi = colfilter(Lo, g1o_t)
                HiLo = colfilter(Hi, g0o_t)
                HiHi = colfilter(Hi, g1o_t)
                deg15, deg165 = q2c(LoHi, ctx.ri_dim)
                deg45, deg135 = q2c(HiHi, ctx.ri_dim)
                deg75, deg105 = q2c(HiLo, ctx.ri_dim)
                grad_yh1 = torch.stack(
                    [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)

            # Level 2 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            if ctx.needs_input_grad[2]:
                Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
                LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
                HiLo = coldfilt(Hi, g0b_t, g0a_t)
                HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

                deg15, deg165 = q2c(LoHi, ctx.ri_dim)
                deg45, deg135 = q2c(HiHi, ctx.ri_dim)
                deg75, deg105 = q2c(HiLo, ctx.ri_dim)
                grad_yh2 = torch.stack(
                    [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            # Level 3 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            if ctx.needs_input_grad[3]:
                Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
                LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
                HiLo = coldfilt(Hi, g0b_t, g0a_t)
                HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

                deg15, deg165 = q2c(LoHi, ctx.ri_dim)
                deg45, deg135 = q2c(HiHi, ctx.ri_dim)
                deg75, deg105 = q2c(HiLo, ctx.ri_dim)
                grad_yh3 = torch.stack(
                    [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            # Level 4 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            if ctx.needs_input_grad[4]:
                Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
                LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
                HiLo = coldfilt(Hi, g0b_t, g0a_t)
                HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

                deg15, deg165 = q2c(LoHi, ctx.ri_dim)
                deg45, deg135 = q2c(HiHi, ctx.ri_dim)
                deg75, deg105 = q2c(HiLo, ctx.ri_dim)
                grad_yh4 = torch.stack(
                    [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            if ctx.needs_input_grad[0]:
                grad_yl = LoLo

        return (grad_yl, grad_yh1, grad_yh2, grad_yh3, grad_yh4) + (None,) * 8


class xfm4scale(Function):

    @staticmethod
    def forward(ctx, input, h0o, h1o, h0a, h0b, h1a, h1b, skip_hps, include_scale, o_dim, ri_dim):
        ctx.save_for_backward(h0o, h1o, h0a, h0b, h1a, h1b)
        ctx.o_dim = (o_dim % 6)
        ctx.ri_dim = (ri_dim % 6)
        if ctx.o_dim < ctx.ri_dim:
            ctx.ri_dim -= 1
        if ctx.o_dim >= 3 and ctx.ri_dim >= 3:
            ctx.h_dim = 2
        elif ctx.o_dim >= 4 or ctx.ri_dim >= 4:
            ctx.h_dim = 3
        else:
            ctx.h_dim = 4
        if ctx.o_dim >= 4 and ctx.ri_dim >= 4:
            ctx.w_dim = 3
        elif ctx.o_dim >=4 or ctx.ri_dim >= 4:
            ctx.w_dim = 4
        else:
            ctx.w_dim = 5

        ctx.in_shape = input.shape
        ctx.skip_hps = skip_hps
        ctx.include_scale = include_scale
        ctx.extra_rows = 0
        ctx.extra_cols = 0
        batch, ch, r, c = input.shape

        # If the row/col count of X is not divisible by 2 then we need to
        # extend X
        if r % 2 != 0:
            input = torch.cat((input, input[:,:,-1:]), dim=2)
            ctx.extra_rows = 1
        if c % 2 != 0:
            input = torch.cat((input, input[:,:,:,-1:]), dim=3)
            ctx.extra_cols = 1

        # Level 1 forward (biorthogonal analysis filters)
        Lo = rowfilter(input, h0o)
        if not ctx.skip_hps[0]:
            Hi = rowfilter(input, h1o)
            LoHi = colfilter(Lo, h1o)
            HiLo = colfilter(Hi, h0o)
            HiHi = colfilter(Hi, h1o)
            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh1 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh1 = torch.tensor([], device=input.device)
        LoLo = colfilter(Lo, h0o)
        if ctx.include_scale[0]:
            Ys1 = LoLo
        else:
            Ys1 = torch.tensor([], device=input.device)
        
        # Level 2 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        if not ctx.skip_hps[1]:
            Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
            LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
            HiLo = coldfilt(Hi, h0b, h0a)
            HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh2 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh2 = torch.tensor([], device=input.device)
        LoLo = coldfilt(Lo, h0b, h0a)
        if ctx.include_scale[1]:
            Ys2 = LoLo
        else:
            Ys2 = torch.tensor([], device=input.device)

        # Level 3 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        if not ctx.skip_hps[2]:
            Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
            LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
            HiLo = coldfilt(Hi, h0b, h0a)
            HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh3 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh3 = torch.tensor([], device=input.device)
        LoLo = coldfilt(Lo, h0b, h0a)
        if ctx.include_scale[2]:
            Ys3 = LoLo
        else:
            Ys3 = torch.tensor([], device=input.device)

        # Level 4 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        if not ctx.skip_hps[3]:
            Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
            LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
            HiLo = coldfilt(Hi, h0b, h0a)
            HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh4 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh4 = torch.tensor([], device=input.device)
        LoLo = coldfilt(Lo, h0b, h0a)
        if ctx.include_scale[3]:
            Ys4 = LoLo
        else:
            Ys4 = torch.tensor([], device=input.device)

        Yl = LoLo
        return Ys1, Ys2, Ys3, Ys4, Yh1, Yh2, Yh3, Yh4

    @staticmethod
    def backward(ctx, grad_Ys1, grad_Ys2, grad_Ys3, grad_Ys4, grad_Yh1, grad_Yh2, grad_Yh3, grad_Yh4):
        h0o, h1o, h0a, h0b, h1a, h1b = ctx.saved_tensors
        in_shape = ctx.in_shape
        grad_input = None
        # Use the special properties of the filters to get the time reverse
        h0o_t = h0o
        h1o_t = h1o
        h0a_t = h0b
        h0b_t = h0a
        h1a_t = h1b
        h1b_t = h1a

        if True in ctx.needs_input_grad:
            ll = grad_Ys4
            
            # Level 4 backward (time reversed quater shift analysis filters)
            if not ctx.skip_hps[3]:
                dev = grad_Yh4.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh4, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh4, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh4, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
                Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
                ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            else:
                ll = rowifilt(colifilt(Lo, h0b_t, h0a_t), h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh3.shape[ctx.h_dim], grad_Yh3.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]
            if ctx.include_scale[2]:
                ll = (ll + grad_Ys3)/2

            # Level 3 backward (time reversed quater shift analysis filters)
            if not ctx.skip_hps[2]:
                dev = grad_Yh3.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh3, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh3, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh3, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
                Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
                ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            else:
                ll = rowifilt(colifilt(Lo, h0b_t, h0a_t), h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh2.shape[ctx.h_dim], grad_Yh2.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]
            if ctx.include_scale[1]:
                ll = (ll + grad_Ys2)/2

            # Level 2 backward (time reversed quater shift analysis filters)
            if not ctx.skip_hps[1]:
                dev = grad_Yh2.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh2, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh2, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh2, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
                Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
                ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            else:
                ll = rowifilt(colifilt(Lo, h0b_t, h0a_t), h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh1.shape[ctx.h_dim], grad_Yh1.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]
            if ctx.include_scale[0]:
                ll = (ll + grad_Ys1)/2

            # Level 1 backward (time reversed biorthogonal analysis filters)
            if not ctx.skip_hps[0]:
                dev = grad_Yh1.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh1, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh1, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh1, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colfilter(hh, h1o_t) + colfilter(hl, h0o_t)
                Lo = colfilter(lh, h1o_t) + colfilter(ll, h0o_t)
                grad_input = rowfilter(Hi, h1o_t) + rowfilter(Lo, h0o_t)
            else:
                grad_input = rowfilter(colfilter(ll, h0o_t), h0o_t)
            if ctx.extra_rows:
                grad_input = grad_input[:,:,:-1]
            if ctx.extra_cols:
                grad_input = grad_input[:,:,:,:-1]
            

        return (grad_input,) + (None,) * 10


class xfm4(Function):

    @staticmethod
    def forward(ctx, input, h0o, h1o, h0a, h0b, h1a, h1b, skip_hps, include_scale, o_dim, ri_dim):
        ctx.save_for_backward(h0o, h1o, h0a, h0b, h1a, h1b)
        ctx.o_dim = (o_dim % 6)
        ctx.ri_dim = (ri_dim % 6)
        if ctx.o_dim < ctx.ri_dim:
            ctx.ri_dim -= 1
        if ctx.o_dim >= 3 and ctx.ri_dim >= 3:
            ctx.h_dim = 2
        elif ctx.o_dim >= 4 or ctx.ri_dim >= 4:
            ctx.h_dim = 3
        else:
            ctx.h_dim = 4
        if ctx.o_dim >= 4 and ctx.ri_dim >= 4:
            ctx.w_dim = 3
        elif ctx.o_dim >=4 or ctx.ri_dim >= 4:
            ctx.w_dim = 4
        else:
            ctx.w_dim = 5

        ctx.in_shape = input.shape
        ctx.skip_hps = skip_hps
        ctx.include_scale = include_scale
        ctx.extra_rows = 0
        ctx.extra_cols = 0
        batch, ch, r, c = input.shape

        # If the row/col count of X is not divisible by 2 then we need to
        # extend X
        if r % 2 != 0:
            input = torch.cat((input, input[:,:,-1:]), dim=2)
            ctx.extra_rows = 1
        if c % 2 != 0:
            input = torch.cat((input, input[:,:,:,-1:]), dim=3)
            ctx.extra_cols = 1

        # Level 1 forward (biorthogonal analysis filters)
        Lo = rowfilter(input, h0o)
        if not ctx.skip_hps[0]:
            Hi = rowfilter(input, h1o)
            LoHi = colfilter(Lo, h1o)
            HiLo = colfilter(Hi, h0o)
            HiHi = colfilter(Hi, h1o)
            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh1 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh1 = torch.tensor([], device=input.device)
        LoLo = colfilter(Lo, h0o)
        if ctx.include_scale[0]:
            Ys1 = LoLo
        else:
            Ys1 = torch.tensor([], device=input.device)
        
        # Level 2 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        if not ctx.skip_hps[1]:
            Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
            LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
            HiLo = coldfilt(Hi, h0b, h0a)
            HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh2 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh2 = torch.tensor([], device=input.device)
        LoLo = coldfilt(Lo, h0b, h0a)
        if ctx.include_scale[1]:
            Ys2 = LoLo
        else:
            Ys2 = torch.tensor([], device=input.device)

        # Level 3 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        if not ctx.skip_hps[2]:
            Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
            LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
            HiLo = coldfilt(Hi, h0b, h0a)
            HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh3 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh3 = torch.tensor([], device=input.device)
        LoLo = coldfilt(Lo, h0b, h0a)
        if ctx.include_scale[2]:
            Ys3 = LoLo
        else:
            Ys3 = torch.tensor([], device=input.device)

        # Level 4 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        if not ctx.skip_hps[3]:
            Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
            LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
            HiLo = coldfilt(Hi, h0b, h0a)
            HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh4 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh4 = torch.tensor([], device=input.device)
        LoLo = coldfilt(Lo, h0b, h0a)
        if ctx.include_scale[3]:
            Ys4 = LoLo
        else:
            Ys4 = torch.tensor([], device=input.device)

        Yl = LoLo
        return Yl, Yh1, Yh2, Yh3, Yh4

    @staticmethod
    def backward(ctx, grad_LoLo, grad_Yh1, grad_Yh2, grad_Yh3, grad_Yh4):
        h0o, h1o, h0a, h0b, h1a, h1b = ctx.saved_tensors
        in_shape = ctx.in_shape
        grad_input = None
        # Use the special properties of the filters to get the time reverse
        h0o_t = h0o
        h1o_t = h1o
        h0a_t = h0b
        h0b_t = h0a
        h1a_t = h1b
        h1b_t = h1a

        if True in ctx.needs_input_grad:
            ll = grad_LoLo
            
            # Level 4 backward (time reversed quater shift analysis filters)
            if not ctx.skip_hps[3]:
                dev = grad_Yh4.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh4, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh4, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh4, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
                Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
                ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            else:
                ll = rowifilt(colifilt(Lo, h0b_t, h0a_t), h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh3.shape[ctx.h_dim], grad_Yh3.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 3 backward (time reversed quater shift analysis filters)
            if not ctx.skip_hps[2]:
                dev = grad_Yh3.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh3, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh3, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh3, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
                Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
                ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            else:
                ll = rowifilt(colifilt(Lo, h0b_t, h0a_t), h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh2.shape[ctx.h_dim], grad_Yh2.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 2 backward (time reversed quater shift analysis filters)
            if not ctx.skip_hps[1]:
                dev = grad_Yh2.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh2, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh2, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh2, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
                Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
                ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            else:
                ll = rowifilt(colifilt(Lo, h0b_t, h0a_t), h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh1.shape[ctx.h_dim], grad_Yh1.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 1 backward (time reversed biorthogonal analysis filters)
            if not ctx.skip_hps[0]:
                dev = grad_Yh1.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh1, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh1, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh1, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colfilter(hh, h1o_t) + colfilter(hl, h0o_t)
                Lo = colfilter(lh, h1o_t) + colfilter(ll, h0o_t)
                grad_input = rowfilter(Hi, h1o_t) + rowfilter(Lo, h0o_t)
            else:
                grad_input = rowfilter(colfilter(ll, h0o_t), h0o_t)
            if ctx.extra_rows:
                grad_input = grad_input[:,:,:-1]
            if ctx.extra_cols:
                grad_input = grad_input[:,:,:,:-1]
            

        return (grad_input,) + (None,) * 10


class ifm5(Function):

    @staticmethod
    def forward(ctx, yl, yh1, yh2, yh3, yh4, yh5, g0o, g1o, g0a, g0b, g1a, g1b, o_dim, ri_dim):
        ctx.save_for_backward(g0o, g1o, g0a, g0b, g1a, g1b)
        ctx.o_dim = (o_dim % 6)
        ctx.ri_dim = (ri_dim % 6)
        if ctx.o_dim < ctx.ri_dim:
            ctx.ri_dim -= 1
        # Get the height and width dimensions
        if ctx.o_dim >= 3 and ctx.ri_dim >= 3:
            ctx.h_dim = 2
        elif ctx.o_dim >= 4 or ctx.ri_dim >= 4:
            ctx.h_dim = 3
        else:
            ctx.h_dim = 4
        if ctx.o_dim >= 4 and ctx.ri_dim >= 4:
            ctx.w_dim = 3
        elif ctx.o_dim >=4 or ctx.ri_dim >= 4:
            ctx.w_dim = 4
        else:
            ctx.w_dim = 5
        ll = yl
        # Level 5 inverse transform with quater shift synthesis filters
        if yh5 is not None and yh5.shape != torch.Size([0]):
            dev = yh5.device
            deg15, deg165 = torch.unbind(torch.index_select(
                yh5, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
            deg45, deg135 = torch.unbind(torch.index_select(
                yh5, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
            deg75, deg105 = torch.unbind(torch.index_select(
                yh5, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
            lh = c2q(deg15, deg165, ctx.ri_dim)
            hl = c2q(deg75, deg105, ctx.ri_dim)
            hh = c2q(deg45, deg135, ctx.ri_dim)
            Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
            if ll is not None and ll.shape != torch.Size([0]):
                Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
            else:
                Lo = colifilt(lh, g1b, g1a, True)
            ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        else:
            ll = rowifilt(colifilt(ll, g0b, g0a), g0b, g0a)
        

        # Level 4 inverse transform with quater shift synthesis filters
        if yh4 is not None and yh4.shape != torch.Size([0]):
            r, c = ll.shape[2:]
            r1, c1 = yh4.shape[ctx.h_dim], yh4.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]
            dev = yh4.device
            deg15, deg165 = torch.unbind(torch.index_select(
                yh4, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
            deg45, deg135 = torch.unbind(torch.index_select(
                yh4, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
            deg75, deg105 = torch.unbind(torch.index_select(
                yh4, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
            lh = c2q(deg15, deg165, ctx.ri_dim)
            hl = c2q(deg75, deg105, ctx.ri_dim)
            hh = c2q(deg45, deg135, ctx.ri_dim)
            Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
            if ll is not None and ll.shape != torch.Size([0]):
                Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
            else:
                Lo = colifilt(lh, g1b, g1a, True)
            ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        else:
            ll = rowifilt(colifilt(ll, g0b, g0a), g0b, g0a)
        

        # Level 3 inverse transform with quater shift synthesis filters
        if yh3 is not None and yh3.shape != torch.Size([0]):
            r, c = ll.shape[2:]
            r1, c1 = yh3.shape[ctx.h_dim], yh3.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]
            dev = yh3.device
            deg15, deg165 = torch.unbind(torch.index_select(
                yh3, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
            deg45, deg135 = torch.unbind(torch.index_select(
                yh3, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
            deg75, deg105 = torch.unbind(torch.index_select(
                yh3, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
            lh = c2q(deg15, deg165, ctx.ri_dim)
            hl = c2q(deg75, deg105, ctx.ri_dim)
            hh = c2q(deg45, deg135, ctx.ri_dim)
            Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
            if ll is not None and ll.shape != torch.Size([0]):
                Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
            else:
                Lo = colifilt(lh, g1b, g1a, True)
            ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        else:
            ll = rowifilt(colifilt(ll, g0b, g0a), g0b, g0a)
        

        # Level 2 inverse transform with quater shift synthesis filters
        if yh2 is not None and yh2.shape != torch.Size([0]):
            r, c = ll.shape[2:]
            r1, c1 = yh2.shape[ctx.h_dim], yh2.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]
            dev = yh2.device
            deg15, deg165 = torch.unbind(torch.index_select(
                yh2, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
            deg45, deg135 = torch.unbind(torch.index_select(
                yh2, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
            deg75, deg105 = torch.unbind(torch.index_select(
                yh2, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
            lh = c2q(deg15, deg165, ctx.ri_dim)
            hl = c2q(deg75, deg105, ctx.ri_dim)
            hh = c2q(deg45, deg135, ctx.ri_dim)
            Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
            if ll is not None and ll.shape != torch.Size([0]):
                Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
            else:
                Lo = colifilt(lh, g1b, g1a, True)
            ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        else:
            ll = rowifilt(colifilt(ll, g0b, g0a), g0b, g0a)
        
        # Level 1 inverse with biorthogonal synthesis filters
        if yh1 is not None and yh1.shape != torch.Size([0]):
            r, c = ll.shape[2:]
            r1, c1 = yh1.shape[ctx.h_dim], yh1.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]
            dev = yh1.device
            deg15, deg165 = torch.unbind(torch.index_select(
                yh1, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
            deg45, deg135 = torch.unbind(torch.index_select(
                yh1, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
            deg75, deg105 = torch.unbind(torch.index_select(
                yh1, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
            lh = c2q(deg15, deg165, ctx.ri_dim)
            hl = c2q(deg75, deg105, ctx.ri_dim)
            hh = c2q(deg45, deg135, ctx.ri_dim)
            Hi = colfilter(hh, g1o) + colfilter(hl, g0o)
            if ll is not None and ll.shape != torch.Size([0]):
                Lo = colfilter(lh, g1o) + colfilter(ll, g0o)
            else:
                Lo = colfilter(lh, g1o)
            y = rowfilter(Hi, g1o) + rowfilter(Lo, g0o)
        else:
            y = rowfilter(colfilter(ll, g0o), g0o)

        return y

    @staticmethod
    def backward(ctx, grad_y):
        g0o, g1o, g0a, g0b, g1a, g1b = ctx.saved_tensors
        grad_yl = None
        grad_yh1 = None
        grad_yh2 = None
        grad_yh3 = None
        grad_yh4 = None
        grad_yh5 = None

        # Use the special properties of the filters to get the time reverse
        g0o_t = g0o
        g1o_t = g1o
        g0a_t = g0b
        g0b_t = g0a
        g1a_t = g1b
        g1b_t = g1a

        if True in ctx.needs_input_grad:
            # Level 1 inverse gradient - same as fwd transform
            # with time reverse biorthogonal synthesis filters
            Lo = rowfilter(grad_y, g0o_t)
            LoLo = colfilter(Lo, g0o_t)
            if ctx.needs_input_grad[1]:
                Hi = rowfilter(grad_y, g1o_t)
                LoHi = colfilter(Lo, g1o_t)
                HiLo = colfilter(Hi, g0o_t)
                HiHi = colfilter(Hi, g1o_t)
                deg15, deg165 = q2c(LoHi, ctx.ri_dim)
                deg45, deg135 = q2c(HiHi, ctx.ri_dim)
                deg75, deg105 = q2c(HiLo, ctx.ri_dim)
                grad_yh1 = torch.stack(
                    [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)

            # Level 2 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            if ctx.needs_input_grad[2]:
                Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
                LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
                HiLo = coldfilt(Hi, g0b_t, g0a_t)
                HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

                deg15, deg165 = q2c(LoHi, ctx.ri_dim)
                deg45, deg135 = q2c(HiHi, ctx.ri_dim)
                deg75, deg105 = q2c(HiLo, ctx.ri_dim)
                grad_yh2 = torch.stack(
                    [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            # Level 3 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            if ctx.needs_input_grad[3]:
                Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
                LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
                HiLo = coldfilt(Hi, g0b_t, g0a_t)
                HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

                deg15, deg165 = q2c(LoHi, ctx.ri_dim)
                deg45, deg135 = q2c(HiHi, ctx.ri_dim)
                deg75, deg105 = q2c(HiLo, ctx.ri_dim)
                grad_yh3 = torch.stack(
                    [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            # Level 4 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            if ctx.needs_input_grad[4]:
                Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
                LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
                HiLo = coldfilt(Hi, g0b_t, g0a_t)
                HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

                deg15, deg165 = q2c(LoHi, ctx.ri_dim)
                deg45, deg135 = q2c(HiHi, ctx.ri_dim)
                deg75, deg105 = q2c(HiLo, ctx.ri_dim)
                grad_yh4 = torch.stack(
                    [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            # Level 5 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            if ctx.needs_input_grad[5]:
                Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
                LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
                HiLo = coldfilt(Hi, g0b_t, g0a_t)
                HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

                deg15, deg165 = q2c(LoHi, ctx.ri_dim)
                deg45, deg135 = q2c(HiHi, ctx.ri_dim)
                deg75, deg105 = q2c(HiLo, ctx.ri_dim)
                grad_yh5 = torch.stack(
                    [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            if ctx.needs_input_grad[0]:
                grad_yl = LoLo

        return (grad_yl, grad_yh1, grad_yh2, grad_yh3, grad_yh4, grad_yh5) + (None,) * 8


class xfm5scale(Function):

    @staticmethod
    def forward(ctx, input, h0o, h1o, h0a, h0b, h1a, h1b, skip_hps, include_scale, o_dim, ri_dim):
        ctx.save_for_backward(h0o, h1o, h0a, h0b, h1a, h1b)
        ctx.o_dim = (o_dim % 6)
        ctx.ri_dim = (ri_dim % 6)
        if ctx.o_dim < ctx.ri_dim:
            ctx.ri_dim -= 1
        if ctx.o_dim >= 3 and ctx.ri_dim >= 3:
            ctx.h_dim = 2
        elif ctx.o_dim >= 4 or ctx.ri_dim >= 4:
            ctx.h_dim = 3
        else:
            ctx.h_dim = 4
        if ctx.o_dim >= 4 and ctx.ri_dim >= 4:
            ctx.w_dim = 3
        elif ctx.o_dim >=4 or ctx.ri_dim >= 4:
            ctx.w_dim = 4
        else:
            ctx.w_dim = 5

        ctx.in_shape = input.shape
        ctx.skip_hps = skip_hps
        ctx.include_scale = include_scale
        ctx.extra_rows = 0
        ctx.extra_cols = 0
        batch, ch, r, c = input.shape

        # If the row/col count of X is not divisible by 2 then we need to
        # extend X
        if r % 2 != 0:
            input = torch.cat((input, input[:,:,-1:]), dim=2)
            ctx.extra_rows = 1
        if c % 2 != 0:
            input = torch.cat((input, input[:,:,:,-1:]), dim=3)
            ctx.extra_cols = 1

        # Level 1 forward (biorthogonal analysis filters)
        Lo = rowfilter(input, h0o)
        if not ctx.skip_hps[0]:
            Hi = rowfilter(input, h1o)
            LoHi = colfilter(Lo, h1o)
            HiLo = colfilter(Hi, h0o)
            HiHi = colfilter(Hi, h1o)
            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh1 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh1 = torch.tensor([], device=input.device)
        LoLo = colfilter(Lo, h0o)
        if ctx.include_scale[0]:
            Ys1 = LoLo
        else:
            Ys1 = torch.tensor([], device=input.device)
        
        # Level 2 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        if not ctx.skip_hps[1]:
            Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
            LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
            HiLo = coldfilt(Hi, h0b, h0a)
            HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh2 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh2 = torch.tensor([], device=input.device)
        LoLo = coldfilt(Lo, h0b, h0a)
        if ctx.include_scale[1]:
            Ys2 = LoLo
        else:
            Ys2 = torch.tensor([], device=input.device)

        # Level 3 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        if not ctx.skip_hps[2]:
            Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
            LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
            HiLo = coldfilt(Hi, h0b, h0a)
            HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh3 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh3 = torch.tensor([], device=input.device)
        LoLo = coldfilt(Lo, h0b, h0a)
        if ctx.include_scale[2]:
            Ys3 = LoLo
        else:
            Ys3 = torch.tensor([], device=input.device)

        # Level 4 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        if not ctx.skip_hps[3]:
            Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
            LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
            HiLo = coldfilt(Hi, h0b, h0a)
            HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh4 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh4 = torch.tensor([], device=input.device)
        LoLo = coldfilt(Lo, h0b, h0a)
        if ctx.include_scale[3]:
            Ys4 = LoLo
        else:
            Ys4 = torch.tensor([], device=input.device)

        # Level 5 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        if not ctx.skip_hps[4]:
            Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
            LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
            HiLo = coldfilt(Hi, h0b, h0a)
            HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh5 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh5 = torch.tensor([], device=input.device)
        LoLo = coldfilt(Lo, h0b, h0a)
        if ctx.include_scale[4]:
            Ys5 = LoLo
        else:
            Ys5 = torch.tensor([], device=input.device)

        Yl = LoLo
        return Ys1, Ys2, Ys3, Ys4, Ys5, Yh1, Yh2, Yh3, Yh4, Yh5

    @staticmethod
    def backward(ctx, grad_Ys1, grad_Ys2, grad_Ys3, grad_Ys4, grad_Ys5, grad_Yh1, grad_Yh2, grad_Yh3, grad_Yh4, grad_Yh5):
        h0o, h1o, h0a, h0b, h1a, h1b = ctx.saved_tensors
        in_shape = ctx.in_shape
        grad_input = None
        # Use the special properties of the filters to get the time reverse
        h0o_t = h0o
        h1o_t = h1o
        h0a_t = h0b
        h0b_t = h0a
        h1a_t = h1b
        h1b_t = h1a

        if True in ctx.needs_input_grad:
            ll = grad_Ys5
            
            # Level 5 backward (time reversed quater shift analysis filters)
            if not ctx.skip_hps[4]:
                dev = grad_Yh5.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh5, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh5, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh5, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
                Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
                ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            else:
                ll = rowifilt(colifilt(Lo, h0b_t, h0a_t), h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh4.shape[ctx.h_dim], grad_Yh4.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]
            if ctx.include_scale[3]:
                ll = (ll + grad_Ys4)/2

            # Level 4 backward (time reversed quater shift analysis filters)
            if not ctx.skip_hps[3]:
                dev = grad_Yh4.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh4, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh4, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh4, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
                Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
                ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            else:
                ll = rowifilt(colifilt(Lo, h0b_t, h0a_t), h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh3.shape[ctx.h_dim], grad_Yh3.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]
            if ctx.include_scale[2]:
                ll = (ll + grad_Ys3)/2

            # Level 3 backward (time reversed quater shift analysis filters)
            if not ctx.skip_hps[2]:
                dev = grad_Yh3.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh3, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh3, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh3, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
                Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
                ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            else:
                ll = rowifilt(colifilt(Lo, h0b_t, h0a_t), h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh2.shape[ctx.h_dim], grad_Yh2.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]
            if ctx.include_scale[1]:
                ll = (ll + grad_Ys2)/2

            # Level 2 backward (time reversed quater shift analysis filters)
            if not ctx.skip_hps[1]:
                dev = grad_Yh2.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh2, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh2, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh2, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
                Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
                ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            else:
                ll = rowifilt(colifilt(Lo, h0b_t, h0a_t), h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh1.shape[ctx.h_dim], grad_Yh1.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]
            if ctx.include_scale[0]:
                ll = (ll + grad_Ys1)/2

            # Level 1 backward (time reversed biorthogonal analysis filters)
            if not ctx.skip_hps[0]:
                dev = grad_Yh1.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh1, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh1, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh1, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colfilter(hh, h1o_t) + colfilter(hl, h0o_t)
                Lo = colfilter(lh, h1o_t) + colfilter(ll, h0o_t)
                grad_input = rowfilter(Hi, h1o_t) + rowfilter(Lo, h0o_t)
            else:
                grad_input = rowfilter(colfilter(ll, h0o_t), h0o_t)
            if ctx.extra_rows:
                grad_input = grad_input[:,:,:-1]
            if ctx.extra_cols:
                grad_input = grad_input[:,:,:,:-1]
            

        return (grad_input,) + (None,) * 10


class xfm5(Function):

    @staticmethod
    def forward(ctx, input, h0o, h1o, h0a, h0b, h1a, h1b, skip_hps, include_scale, o_dim, ri_dim):
        ctx.save_for_backward(h0o, h1o, h0a, h0b, h1a, h1b)
        ctx.o_dim = (o_dim % 6)
        ctx.ri_dim = (ri_dim % 6)
        if ctx.o_dim < ctx.ri_dim:
            ctx.ri_dim -= 1
        if ctx.o_dim >= 3 and ctx.ri_dim >= 3:
            ctx.h_dim = 2
        elif ctx.o_dim >= 4 or ctx.ri_dim >= 4:
            ctx.h_dim = 3
        else:
            ctx.h_dim = 4
        if ctx.o_dim >= 4 and ctx.ri_dim >= 4:
            ctx.w_dim = 3
        elif ctx.o_dim >=4 or ctx.ri_dim >= 4:
            ctx.w_dim = 4
        else:
            ctx.w_dim = 5

        ctx.in_shape = input.shape
        ctx.skip_hps = skip_hps
        ctx.include_scale = include_scale
        ctx.extra_rows = 0
        ctx.extra_cols = 0
        batch, ch, r, c = input.shape

        # If the row/col count of X is not divisible by 2 then we need to
        # extend X
        if r % 2 != 0:
            input = torch.cat((input, input[:,:,-1:]), dim=2)
            ctx.extra_rows = 1
        if c % 2 != 0:
            input = torch.cat((input, input[:,:,:,-1:]), dim=3)
            ctx.extra_cols = 1

        # Level 1 forward (biorthogonal analysis filters)
        Lo = rowfilter(input, h0o)
        if not ctx.skip_hps[0]:
            Hi = rowfilter(input, h1o)
            LoHi = colfilter(Lo, h1o)
            HiLo = colfilter(Hi, h0o)
            HiHi = colfilter(Hi, h1o)
            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh1 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh1 = torch.tensor([], device=input.device)
        LoLo = colfilter(Lo, h0o)
        if ctx.include_scale[0]:
            Ys1 = LoLo
        else:
            Ys1 = torch.tensor([], device=input.device)
        
        # Level 2 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        if not ctx.skip_hps[1]:
            Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
            LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
            HiLo = coldfilt(Hi, h0b, h0a)
            HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh2 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh2 = torch.tensor([], device=input.device)
        LoLo = coldfilt(Lo, h0b, h0a)
        if ctx.include_scale[1]:
            Ys2 = LoLo
        else:
            Ys2 = torch.tensor([], device=input.device)

        # Level 3 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        if not ctx.skip_hps[2]:
            Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
            LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
            HiLo = coldfilt(Hi, h0b, h0a)
            HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh3 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh3 = torch.tensor([], device=input.device)
        LoLo = coldfilt(Lo, h0b, h0a)
        if ctx.include_scale[2]:
            Ys3 = LoLo
        else:
            Ys3 = torch.tensor([], device=input.device)

        # Level 4 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        if not ctx.skip_hps[3]:
            Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
            LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
            HiLo = coldfilt(Hi, h0b, h0a)
            HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh4 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh4 = torch.tensor([], device=input.device)
        LoLo = coldfilt(Lo, h0b, h0a)
        if ctx.include_scale[3]:
            Ys4 = LoLo
        else:
            Ys4 = torch.tensor([], device=input.device)

        # Level 5 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        if not ctx.skip_hps[4]:
            Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
            LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
            HiLo = coldfilt(Hi, h0b, h0a)
            HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh5 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh5 = torch.tensor([], device=input.device)
        LoLo = coldfilt(Lo, h0b, h0a)
        if ctx.include_scale[4]:
            Ys5 = LoLo
        else:
            Ys5 = torch.tensor([], device=input.device)

        Yl = LoLo
        return Yl, Yh1, Yh2, Yh3, Yh4, Yh5

    @staticmethod
    def backward(ctx, grad_LoLo, grad_Yh1, grad_Yh2, grad_Yh3, grad_Yh4, grad_Yh5):
        h0o, h1o, h0a, h0b, h1a, h1b = ctx.saved_tensors
        in_shape = ctx.in_shape
        grad_input = None
        # Use the special properties of the filters to get the time reverse
        h0o_t = h0o
        h1o_t = h1o
        h0a_t = h0b
        h0b_t = h0a
        h1a_t = h1b
        h1b_t = h1a

        if True in ctx.needs_input_grad:
            ll = grad_LoLo
            
            # Level 5 backward (time reversed quater shift analysis filters)
            if not ctx.skip_hps[4]:
                dev = grad_Yh5.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh5, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh5, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh5, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
                Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
                ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            else:
                ll = rowifilt(colifilt(Lo, h0b_t, h0a_t), h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh4.shape[ctx.h_dim], grad_Yh4.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 4 backward (time reversed quater shift analysis filters)
            if not ctx.skip_hps[3]:
                dev = grad_Yh4.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh4, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh4, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh4, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
                Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
                ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            else:
                ll = rowifilt(colifilt(Lo, h0b_t, h0a_t), h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh3.shape[ctx.h_dim], grad_Yh3.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 3 backward (time reversed quater shift analysis filters)
            if not ctx.skip_hps[2]:
                dev = grad_Yh3.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh3, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh3, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh3, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
                Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
                ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            else:
                ll = rowifilt(colifilt(Lo, h0b_t, h0a_t), h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh2.shape[ctx.h_dim], grad_Yh2.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 2 backward (time reversed quater shift analysis filters)
            if not ctx.skip_hps[1]:
                dev = grad_Yh2.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh2, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh2, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh2, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
                Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
                ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            else:
                ll = rowifilt(colifilt(Lo, h0b_t, h0a_t), h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh1.shape[ctx.h_dim], grad_Yh1.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 1 backward (time reversed biorthogonal analysis filters)
            if not ctx.skip_hps[0]:
                dev = grad_Yh1.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh1, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh1, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh1, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colfilter(hh, h1o_t) + colfilter(hl, h0o_t)
                Lo = colfilter(lh, h1o_t) + colfilter(ll, h0o_t)
                grad_input = rowfilter(Hi, h1o_t) + rowfilter(Lo, h0o_t)
            else:
                grad_input = rowfilter(colfilter(ll, h0o_t), h0o_t)
            if ctx.extra_rows:
                grad_input = grad_input[:,:,:-1]
            if ctx.extra_cols:
                grad_input = grad_input[:,:,:,:-1]
            

        return (grad_input,) + (None,) * 10


class ifm6(Function):

    @staticmethod
    def forward(ctx, yl, yh1, yh2, yh3, yh4, yh5, yh6, g0o, g1o, g0a, g0b, g1a, g1b, o_dim, ri_dim):
        ctx.save_for_backward(g0o, g1o, g0a, g0b, g1a, g1b)
        ctx.o_dim = (o_dim % 6)
        ctx.ri_dim = (ri_dim % 6)
        if ctx.o_dim < ctx.ri_dim:
            ctx.ri_dim -= 1
        # Get the height and width dimensions
        if ctx.o_dim >= 3 and ctx.ri_dim >= 3:
            ctx.h_dim = 2
        elif ctx.o_dim >= 4 or ctx.ri_dim >= 4:
            ctx.h_dim = 3
        else:
            ctx.h_dim = 4
        if ctx.o_dim >= 4 and ctx.ri_dim >= 4:
            ctx.w_dim = 3
        elif ctx.o_dim >=4 or ctx.ri_dim >= 4:
            ctx.w_dim = 4
        else:
            ctx.w_dim = 5
        ll = yl
        # Level 6 inverse transform with quater shift synthesis filters
        if yh6 is not None and yh6.shape != torch.Size([0]):
            dev = yh6.device
            deg15, deg165 = torch.unbind(torch.index_select(
                yh6, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
            deg45, deg135 = torch.unbind(torch.index_select(
                yh6, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
            deg75, deg105 = torch.unbind(torch.index_select(
                yh6, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
            lh = c2q(deg15, deg165, ctx.ri_dim)
            hl = c2q(deg75, deg105, ctx.ri_dim)
            hh = c2q(deg45, deg135, ctx.ri_dim)
            Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
            if ll is not None and ll.shape != torch.Size([0]):
                Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
            else:
                Lo = colifilt(lh, g1b, g1a, True)
            ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        else:
            ll = rowifilt(colifilt(ll, g0b, g0a), g0b, g0a)
        

        # Level 5 inverse transform with quater shift synthesis filters
        if yh5 is not None and yh5.shape != torch.Size([0]):
            r, c = ll.shape[2:]
            r1, c1 = yh5.shape[ctx.h_dim], yh5.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]
            dev = yh5.device
            deg15, deg165 = torch.unbind(torch.index_select(
                yh5, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
            deg45, deg135 = torch.unbind(torch.index_select(
                yh5, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
            deg75, deg105 = torch.unbind(torch.index_select(
                yh5, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
            lh = c2q(deg15, deg165, ctx.ri_dim)
            hl = c2q(deg75, deg105, ctx.ri_dim)
            hh = c2q(deg45, deg135, ctx.ri_dim)
            Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
            if ll is not None and ll.shape != torch.Size([0]):
                Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
            else:
                Lo = colifilt(lh, g1b, g1a, True)
            ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        else:
            ll = rowifilt(colifilt(ll, g0b, g0a), g0b, g0a)
        

        # Level 4 inverse transform with quater shift synthesis filters
        if yh4 is not None and yh4.shape != torch.Size([0]):
            r, c = ll.shape[2:]
            r1, c1 = yh4.shape[ctx.h_dim], yh4.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]
            dev = yh4.device
            deg15, deg165 = torch.unbind(torch.index_select(
                yh4, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
            deg45, deg135 = torch.unbind(torch.index_select(
                yh4, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
            deg75, deg105 = torch.unbind(torch.index_select(
                yh4, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
            lh = c2q(deg15, deg165, ctx.ri_dim)
            hl = c2q(deg75, deg105, ctx.ri_dim)
            hh = c2q(deg45, deg135, ctx.ri_dim)
            Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
            if ll is not None and ll.shape != torch.Size([0]):
                Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
            else:
                Lo = colifilt(lh, g1b, g1a, True)
            ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        else:
            ll = rowifilt(colifilt(ll, g0b, g0a), g0b, g0a)
        

        # Level 3 inverse transform with quater shift synthesis filters
        if yh3 is not None and yh3.shape != torch.Size([0]):
            r, c = ll.shape[2:]
            r1, c1 = yh3.shape[ctx.h_dim], yh3.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]
            dev = yh3.device
            deg15, deg165 = torch.unbind(torch.index_select(
                yh3, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
            deg45, deg135 = torch.unbind(torch.index_select(
                yh3, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
            deg75, deg105 = torch.unbind(torch.index_select(
                yh3, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
            lh = c2q(deg15, deg165, ctx.ri_dim)
            hl = c2q(deg75, deg105, ctx.ri_dim)
            hh = c2q(deg45, deg135, ctx.ri_dim)
            Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
            if ll is not None and ll.shape != torch.Size([0]):
                Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
            else:
                Lo = colifilt(lh, g1b, g1a, True)
            ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        else:
            ll = rowifilt(colifilt(ll, g0b, g0a), g0b, g0a)
        

        # Level 2 inverse transform with quater shift synthesis filters
        if yh2 is not None and yh2.shape != torch.Size([0]):
            r, c = ll.shape[2:]
            r1, c1 = yh2.shape[ctx.h_dim], yh2.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]
            dev = yh2.device
            deg15, deg165 = torch.unbind(torch.index_select(
                yh2, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
            deg45, deg135 = torch.unbind(torch.index_select(
                yh2, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
            deg75, deg105 = torch.unbind(torch.index_select(
                yh2, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
            lh = c2q(deg15, deg165, ctx.ri_dim)
            hl = c2q(deg75, deg105, ctx.ri_dim)
            hh = c2q(deg45, deg135, ctx.ri_dim)
            Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
            if ll is not None and ll.shape != torch.Size([0]):
                Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
            else:
                Lo = colifilt(lh, g1b, g1a, True)
            ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        else:
            ll = rowifilt(colifilt(ll, g0b, g0a), g0b, g0a)
        
        # Level 1 inverse with biorthogonal synthesis filters
        if yh1 is not None and yh1.shape != torch.Size([0]):
            r, c = ll.shape[2:]
            r1, c1 = yh1.shape[ctx.h_dim], yh1.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]
            dev = yh1.device
            deg15, deg165 = torch.unbind(torch.index_select(
                yh1, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
            deg45, deg135 = torch.unbind(torch.index_select(
                yh1, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
            deg75, deg105 = torch.unbind(torch.index_select(
                yh1, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
            lh = c2q(deg15, deg165, ctx.ri_dim)
            hl = c2q(deg75, deg105, ctx.ri_dim)
            hh = c2q(deg45, deg135, ctx.ri_dim)
            Hi = colfilter(hh, g1o) + colfilter(hl, g0o)
            if ll is not None and ll.shape != torch.Size([0]):
                Lo = colfilter(lh, g1o) + colfilter(ll, g0o)
            else:
                Lo = colfilter(lh, g1o)
            y = rowfilter(Hi, g1o) + rowfilter(Lo, g0o)
        else:
            y = rowfilter(colfilter(ll, g0o), g0o)

        return y

    @staticmethod
    def backward(ctx, grad_y):
        g0o, g1o, g0a, g0b, g1a, g1b = ctx.saved_tensors
        grad_yl = None
        grad_yh1 = None
        grad_yh2 = None
        grad_yh3 = None
        grad_yh4 = None
        grad_yh5 = None
        grad_yh6 = None

        # Use the special properties of the filters to get the time reverse
        g0o_t = g0o
        g1o_t = g1o
        g0a_t = g0b
        g0b_t = g0a
        g1a_t = g1b
        g1b_t = g1a

        if True in ctx.needs_input_grad:
            # Level 1 inverse gradient - same as fwd transform
            # with time reverse biorthogonal synthesis filters
            Lo = rowfilter(grad_y, g0o_t)
            LoLo = colfilter(Lo, g0o_t)
            if ctx.needs_input_grad[1]:
                Hi = rowfilter(grad_y, g1o_t)
                LoHi = colfilter(Lo, g1o_t)
                HiLo = colfilter(Hi, g0o_t)
                HiHi = colfilter(Hi, g1o_t)
                deg15, deg165 = q2c(LoHi, ctx.ri_dim)
                deg45, deg135 = q2c(HiHi, ctx.ri_dim)
                deg75, deg105 = q2c(HiLo, ctx.ri_dim)
                grad_yh1 = torch.stack(
                    [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)

            # Level 2 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            if ctx.needs_input_grad[2]:
                Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
                LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
                HiLo = coldfilt(Hi, g0b_t, g0a_t)
                HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

                deg15, deg165 = q2c(LoHi, ctx.ri_dim)
                deg45, deg135 = q2c(HiHi, ctx.ri_dim)
                deg75, deg105 = q2c(HiLo, ctx.ri_dim)
                grad_yh2 = torch.stack(
                    [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            # Level 3 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            if ctx.needs_input_grad[3]:
                Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
                LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
                HiLo = coldfilt(Hi, g0b_t, g0a_t)
                HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

                deg15, deg165 = q2c(LoHi, ctx.ri_dim)
                deg45, deg135 = q2c(HiHi, ctx.ri_dim)
                deg75, deg105 = q2c(HiLo, ctx.ri_dim)
                grad_yh3 = torch.stack(
                    [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            # Level 4 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            if ctx.needs_input_grad[4]:
                Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
                LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
                HiLo = coldfilt(Hi, g0b_t, g0a_t)
                HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

                deg15, deg165 = q2c(LoHi, ctx.ri_dim)
                deg45, deg135 = q2c(HiHi, ctx.ri_dim)
                deg75, deg105 = q2c(HiLo, ctx.ri_dim)
                grad_yh4 = torch.stack(
                    [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            # Level 5 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            if ctx.needs_input_grad[5]:
                Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
                LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
                HiLo = coldfilt(Hi, g0b_t, g0a_t)
                HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

                deg15, deg165 = q2c(LoHi, ctx.ri_dim)
                deg45, deg135 = q2c(HiHi, ctx.ri_dim)
                deg75, deg105 = q2c(HiLo, ctx.ri_dim)
                grad_yh5 = torch.stack(
                    [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            # Level 6 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            if ctx.needs_input_grad[6]:
                Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
                LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
                HiLo = coldfilt(Hi, g0b_t, g0a_t)
                HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

                deg15, deg165 = q2c(LoHi, ctx.ri_dim)
                deg45, deg135 = q2c(HiHi, ctx.ri_dim)
                deg75, deg105 = q2c(HiLo, ctx.ri_dim)
                grad_yh6 = torch.stack(
                    [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            if ctx.needs_input_grad[0]:
                grad_yl = LoLo

        return (grad_yl, grad_yh1, grad_yh2, grad_yh3, grad_yh4, grad_yh5, grad_yh6) + (None,) * 8


class xfm6scale(Function):

    @staticmethod
    def forward(ctx, input, h0o, h1o, h0a, h0b, h1a, h1b, skip_hps, include_scale, o_dim, ri_dim):
        ctx.save_for_backward(h0o, h1o, h0a, h0b, h1a, h1b)
        ctx.o_dim = (o_dim % 6)
        ctx.ri_dim = (ri_dim % 6)
        if ctx.o_dim < ctx.ri_dim:
            ctx.ri_dim -= 1
        if ctx.o_dim >= 3 and ctx.ri_dim >= 3:
            ctx.h_dim = 2
        elif ctx.o_dim >= 4 or ctx.ri_dim >= 4:
            ctx.h_dim = 3
        else:
            ctx.h_dim = 4
        if ctx.o_dim >= 4 and ctx.ri_dim >= 4:
            ctx.w_dim = 3
        elif ctx.o_dim >=4 or ctx.ri_dim >= 4:
            ctx.w_dim = 4
        else:
            ctx.w_dim = 5

        ctx.in_shape = input.shape
        ctx.skip_hps = skip_hps
        ctx.include_scale = include_scale
        ctx.extra_rows = 0
        ctx.extra_cols = 0
        batch, ch, r, c = input.shape

        # If the row/col count of X is not divisible by 2 then we need to
        # extend X
        if r % 2 != 0:
            input = torch.cat((input, input[:,:,-1:]), dim=2)
            ctx.extra_rows = 1
        if c % 2 != 0:
            input = torch.cat((input, input[:,:,:,-1:]), dim=3)
            ctx.extra_cols = 1

        # Level 1 forward (biorthogonal analysis filters)
        Lo = rowfilter(input, h0o)
        if not ctx.skip_hps[0]:
            Hi = rowfilter(input, h1o)
            LoHi = colfilter(Lo, h1o)
            HiLo = colfilter(Hi, h0o)
            HiHi = colfilter(Hi, h1o)
            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh1 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh1 = torch.tensor([], device=input.device)
        LoLo = colfilter(Lo, h0o)
        if ctx.include_scale[0]:
            Ys1 = LoLo
        else:
            Ys1 = torch.tensor([], device=input.device)
        
        # Level 2 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        if not ctx.skip_hps[1]:
            Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
            LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
            HiLo = coldfilt(Hi, h0b, h0a)
            HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh2 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh2 = torch.tensor([], device=input.device)
        LoLo = coldfilt(Lo, h0b, h0a)
        if ctx.include_scale[1]:
            Ys2 = LoLo
        else:
            Ys2 = torch.tensor([], device=input.device)

        # Level 3 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        if not ctx.skip_hps[2]:
            Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
            LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
            HiLo = coldfilt(Hi, h0b, h0a)
            HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh3 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh3 = torch.tensor([], device=input.device)
        LoLo = coldfilt(Lo, h0b, h0a)
        if ctx.include_scale[2]:
            Ys3 = LoLo
        else:
            Ys3 = torch.tensor([], device=input.device)

        # Level 4 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        if not ctx.skip_hps[3]:
            Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
            LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
            HiLo = coldfilt(Hi, h0b, h0a)
            HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh4 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh4 = torch.tensor([], device=input.device)
        LoLo = coldfilt(Lo, h0b, h0a)
        if ctx.include_scale[3]:
            Ys4 = LoLo
        else:
            Ys4 = torch.tensor([], device=input.device)

        # Level 5 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        if not ctx.skip_hps[4]:
            Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
            LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
            HiLo = coldfilt(Hi, h0b, h0a)
            HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh5 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh5 = torch.tensor([], device=input.device)
        LoLo = coldfilt(Lo, h0b, h0a)
        if ctx.include_scale[4]:
            Ys5 = LoLo
        else:
            Ys5 = torch.tensor([], device=input.device)

        # Level 6 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        if not ctx.skip_hps[5]:
            Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
            LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
            HiLo = coldfilt(Hi, h0b, h0a)
            HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh6 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh6 = torch.tensor([], device=input.device)
        LoLo = coldfilt(Lo, h0b, h0a)
        if ctx.include_scale[5]:
            Ys6 = LoLo
        else:
            Ys6 = torch.tensor([], device=input.device)

        Yl = LoLo
        return Ys1, Ys2, Ys3, Ys4, Ys5, Ys6, Yh1, Yh2, Yh3, Yh4, Yh5, Yh6

    @staticmethod
    def backward(ctx, grad_Ys1, grad_Ys2, grad_Ys3, grad_Ys4, grad_Ys5, grad_Ys6, grad_Yh1, grad_Yh2, grad_Yh3, grad_Yh4, grad_Yh5, grad_Yh6):
        h0o, h1o, h0a, h0b, h1a, h1b = ctx.saved_tensors
        in_shape = ctx.in_shape
        grad_input = None
        # Use the special properties of the filters to get the time reverse
        h0o_t = h0o
        h1o_t = h1o
        h0a_t = h0b
        h0b_t = h0a
        h1a_t = h1b
        h1b_t = h1a

        if True in ctx.needs_input_grad:
            ll = grad_Ys6
            
            # Level 6 backward (time reversed quater shift analysis filters)
            if not ctx.skip_hps[5]:
                dev = grad_Yh6.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh6, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh6, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh6, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
                Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
                ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            else:
                ll = rowifilt(colifilt(Lo, h0b_t, h0a_t), h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh5.shape[ctx.h_dim], grad_Yh5.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]
            if ctx.include_scale[4]:
                ll = (ll + grad_Ys5)/2

            # Level 5 backward (time reversed quater shift analysis filters)
            if not ctx.skip_hps[4]:
                dev = grad_Yh5.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh5, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh5, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh5, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
                Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
                ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            else:
                ll = rowifilt(colifilt(Lo, h0b_t, h0a_t), h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh4.shape[ctx.h_dim], grad_Yh4.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]
            if ctx.include_scale[3]:
                ll = (ll + grad_Ys4)/2

            # Level 4 backward (time reversed quater shift analysis filters)
            if not ctx.skip_hps[3]:
                dev = grad_Yh4.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh4, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh4, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh4, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
                Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
                ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            else:
                ll = rowifilt(colifilt(Lo, h0b_t, h0a_t), h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh3.shape[ctx.h_dim], grad_Yh3.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]
            if ctx.include_scale[2]:
                ll = (ll + grad_Ys3)/2

            # Level 3 backward (time reversed quater shift analysis filters)
            if not ctx.skip_hps[2]:
                dev = grad_Yh3.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh3, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh3, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh3, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
                Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
                ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            else:
                ll = rowifilt(colifilt(Lo, h0b_t, h0a_t), h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh2.shape[ctx.h_dim], grad_Yh2.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]
            if ctx.include_scale[1]:
                ll = (ll + grad_Ys2)/2

            # Level 2 backward (time reversed quater shift analysis filters)
            if not ctx.skip_hps[1]:
                dev = grad_Yh2.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh2, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh2, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh2, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
                Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
                ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            else:
                ll = rowifilt(colifilt(Lo, h0b_t, h0a_t), h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh1.shape[ctx.h_dim], grad_Yh1.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]
            if ctx.include_scale[0]:
                ll = (ll + grad_Ys1)/2

            # Level 1 backward (time reversed biorthogonal analysis filters)
            if not ctx.skip_hps[0]:
                dev = grad_Yh1.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh1, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh1, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh1, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colfilter(hh, h1o_t) + colfilter(hl, h0o_t)
                Lo = colfilter(lh, h1o_t) + colfilter(ll, h0o_t)
                grad_input = rowfilter(Hi, h1o_t) + rowfilter(Lo, h0o_t)
            else:
                grad_input = rowfilter(colfilter(ll, h0o_t), h0o_t)
            if ctx.extra_rows:
                grad_input = grad_input[:,:,:-1]
            if ctx.extra_cols:
                grad_input = grad_input[:,:,:,:-1]
            

        return (grad_input,) + (None,) * 10


class xfm6(Function):

    @staticmethod
    def forward(ctx, input, h0o, h1o, h0a, h0b, h1a, h1b, skip_hps, include_scale, o_dim, ri_dim):
        ctx.save_for_backward(h0o, h1o, h0a, h0b, h1a, h1b)
        ctx.o_dim = (o_dim % 6)
        ctx.ri_dim = (ri_dim % 6)
        if ctx.o_dim < ctx.ri_dim:
            ctx.ri_dim -= 1
        if ctx.o_dim >= 3 and ctx.ri_dim >= 3:
            ctx.h_dim = 2
        elif ctx.o_dim >= 4 or ctx.ri_dim >= 4:
            ctx.h_dim = 3
        else:
            ctx.h_dim = 4
        if ctx.o_dim >= 4 and ctx.ri_dim >= 4:
            ctx.w_dim = 3
        elif ctx.o_dim >=4 or ctx.ri_dim >= 4:
            ctx.w_dim = 4
        else:
            ctx.w_dim = 5

        ctx.in_shape = input.shape
        ctx.skip_hps = skip_hps
        ctx.include_scale = include_scale
        ctx.extra_rows = 0
        ctx.extra_cols = 0
        batch, ch, r, c = input.shape

        # If the row/col count of X is not divisible by 2 then we need to
        # extend X
        if r % 2 != 0:
            input = torch.cat((input, input[:,:,-1:]), dim=2)
            ctx.extra_rows = 1
        if c % 2 != 0:
            input = torch.cat((input, input[:,:,:,-1:]), dim=3)
            ctx.extra_cols = 1

        # Level 1 forward (biorthogonal analysis filters)
        Lo = rowfilter(input, h0o)
        if not ctx.skip_hps[0]:
            Hi = rowfilter(input, h1o)
            LoHi = colfilter(Lo, h1o)
            HiLo = colfilter(Hi, h0o)
            HiHi = colfilter(Hi, h1o)
            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh1 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh1 = torch.tensor([], device=input.device)
        LoLo = colfilter(Lo, h0o)
        if ctx.include_scale[0]:
            Ys1 = LoLo
        else:
            Ys1 = torch.tensor([], device=input.device)
        
        # Level 2 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        if not ctx.skip_hps[1]:
            Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
            LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
            HiLo = coldfilt(Hi, h0b, h0a)
            HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh2 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh2 = torch.tensor([], device=input.device)
        LoLo = coldfilt(Lo, h0b, h0a)
        if ctx.include_scale[1]:
            Ys2 = LoLo
        else:
            Ys2 = torch.tensor([], device=input.device)

        # Level 3 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        if not ctx.skip_hps[2]:
            Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
            LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
            HiLo = coldfilt(Hi, h0b, h0a)
            HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh3 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh3 = torch.tensor([], device=input.device)
        LoLo = coldfilt(Lo, h0b, h0a)
        if ctx.include_scale[2]:
            Ys3 = LoLo
        else:
            Ys3 = torch.tensor([], device=input.device)

        # Level 4 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        if not ctx.skip_hps[3]:
            Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
            LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
            HiLo = coldfilt(Hi, h0b, h0a)
            HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh4 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh4 = torch.tensor([], device=input.device)
        LoLo = coldfilt(Lo, h0b, h0a)
        if ctx.include_scale[3]:
            Ys4 = LoLo
        else:
            Ys4 = torch.tensor([], device=input.device)

        # Level 5 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        if not ctx.skip_hps[4]:
            Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
            LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
            HiLo = coldfilt(Hi, h0b, h0a)
            HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh5 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh5 = torch.tensor([], device=input.device)
        LoLo = coldfilt(Lo, h0b, h0a)
        if ctx.include_scale[4]:
            Ys5 = LoLo
        else:
            Ys5 = torch.tensor([], device=input.device)

        # Level 6 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        if not ctx.skip_hps[5]:
            Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
            LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
            HiLo = coldfilt(Hi, h0b, h0a)
            HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh6 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh6 = torch.tensor([], device=input.device)
        LoLo = coldfilt(Lo, h0b, h0a)
        if ctx.include_scale[5]:
            Ys6 = LoLo
        else:
            Ys6 = torch.tensor([], device=input.device)

        Yl = LoLo
        return Yl, Yh1, Yh2, Yh3, Yh4, Yh5, Yh6

    @staticmethod
    def backward(ctx, grad_LoLo, grad_Yh1, grad_Yh2, grad_Yh3, grad_Yh4, grad_Yh5, grad_Yh6):
        h0o, h1o, h0a, h0b, h1a, h1b = ctx.saved_tensors
        in_shape = ctx.in_shape
        grad_input = None
        # Use the special properties of the filters to get the time reverse
        h0o_t = h0o
        h1o_t = h1o
        h0a_t = h0b
        h0b_t = h0a
        h1a_t = h1b
        h1b_t = h1a

        if True in ctx.needs_input_grad:
            ll = grad_LoLo
            
            # Level 6 backward (time reversed quater shift analysis filters)
            if not ctx.skip_hps[5]:
                dev = grad_Yh6.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh6, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh6, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh6, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
                Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
                ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            else:
                ll = rowifilt(colifilt(Lo, h0b_t, h0a_t), h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh5.shape[ctx.h_dim], grad_Yh5.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 5 backward (time reversed quater shift analysis filters)
            if not ctx.skip_hps[4]:
                dev = grad_Yh5.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh5, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh5, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh5, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
                Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
                ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            else:
                ll = rowifilt(colifilt(Lo, h0b_t, h0a_t), h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh4.shape[ctx.h_dim], grad_Yh4.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 4 backward (time reversed quater shift analysis filters)
            if not ctx.skip_hps[3]:
                dev = grad_Yh4.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh4, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh4, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh4, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
                Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
                ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            else:
                ll = rowifilt(colifilt(Lo, h0b_t, h0a_t), h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh3.shape[ctx.h_dim], grad_Yh3.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 3 backward (time reversed quater shift analysis filters)
            if not ctx.skip_hps[2]:
                dev = grad_Yh3.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh3, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh3, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh3, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
                Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
                ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            else:
                ll = rowifilt(colifilt(Lo, h0b_t, h0a_t), h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh2.shape[ctx.h_dim], grad_Yh2.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 2 backward (time reversed quater shift analysis filters)
            if not ctx.skip_hps[1]:
                dev = grad_Yh2.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh2, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh2, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh2, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
                Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
                ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            else:
                ll = rowifilt(colifilt(Lo, h0b_t, h0a_t), h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh1.shape[ctx.h_dim], grad_Yh1.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 1 backward (time reversed biorthogonal analysis filters)
            if not ctx.skip_hps[0]:
                dev = grad_Yh1.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh1, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh1, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh1, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colfilter(hh, h1o_t) + colfilter(hl, h0o_t)
                Lo = colfilter(lh, h1o_t) + colfilter(ll, h0o_t)
                grad_input = rowfilter(Hi, h1o_t) + rowfilter(Lo, h0o_t)
            else:
                grad_input = rowfilter(colfilter(ll, h0o_t), h0o_t)
            if ctx.extra_rows:
                grad_input = grad_input[:,:,:-1]
            if ctx.extra_cols:
                grad_input = grad_input[:,:,:,:-1]
            

        return (grad_input,) + (None,) * 10


class ifm7(Function):

    @staticmethod
    def forward(ctx, yl, yh1, yh2, yh3, yh4, yh5, yh6, yh7, g0o, g1o, g0a, g0b, g1a, g1b, o_dim, ri_dim):
        ctx.save_for_backward(g0o, g1o, g0a, g0b, g1a, g1b)
        ctx.o_dim = (o_dim % 6)
        ctx.ri_dim = (ri_dim % 6)
        if ctx.o_dim < ctx.ri_dim:
            ctx.ri_dim -= 1
        # Get the height and width dimensions
        if ctx.o_dim >= 3 and ctx.ri_dim >= 3:
            ctx.h_dim = 2
        elif ctx.o_dim >= 4 or ctx.ri_dim >= 4:
            ctx.h_dim = 3
        else:
            ctx.h_dim = 4
        if ctx.o_dim >= 4 and ctx.ri_dim >= 4:
            ctx.w_dim = 3
        elif ctx.o_dim >=4 or ctx.ri_dim >= 4:
            ctx.w_dim = 4
        else:
            ctx.w_dim = 5
        ll = yl
        # Level 7 inverse transform with quater shift synthesis filters
        if yh7 is not None and yh7.shape != torch.Size([0]):
            dev = yh7.device
            deg15, deg165 = torch.unbind(torch.index_select(
                yh7, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
            deg45, deg135 = torch.unbind(torch.index_select(
                yh7, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
            deg75, deg105 = torch.unbind(torch.index_select(
                yh7, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
            lh = c2q(deg15, deg165, ctx.ri_dim)
            hl = c2q(deg75, deg105, ctx.ri_dim)
            hh = c2q(deg45, deg135, ctx.ri_dim)
            Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
            if ll is not None and ll.shape != torch.Size([0]):
                Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
            else:
                Lo = colifilt(lh, g1b, g1a, True)
            ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        else:
            ll = rowifilt(colifilt(ll, g0b, g0a), g0b, g0a)
        

        # Level 6 inverse transform with quater shift synthesis filters
        if yh6 is not None and yh6.shape != torch.Size([0]):
            r, c = ll.shape[2:]
            r1, c1 = yh6.shape[ctx.h_dim], yh6.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]
            dev = yh6.device
            deg15, deg165 = torch.unbind(torch.index_select(
                yh6, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
            deg45, deg135 = torch.unbind(torch.index_select(
                yh6, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
            deg75, deg105 = torch.unbind(torch.index_select(
                yh6, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
            lh = c2q(deg15, deg165, ctx.ri_dim)
            hl = c2q(deg75, deg105, ctx.ri_dim)
            hh = c2q(deg45, deg135, ctx.ri_dim)
            Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
            if ll is not None and ll.shape != torch.Size([0]):
                Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
            else:
                Lo = colifilt(lh, g1b, g1a, True)
            ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        else:
            ll = rowifilt(colifilt(ll, g0b, g0a), g0b, g0a)
        

        # Level 5 inverse transform with quater shift synthesis filters
        if yh5 is not None and yh5.shape != torch.Size([0]):
            r, c = ll.shape[2:]
            r1, c1 = yh5.shape[ctx.h_dim], yh5.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]
            dev = yh5.device
            deg15, deg165 = torch.unbind(torch.index_select(
                yh5, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
            deg45, deg135 = torch.unbind(torch.index_select(
                yh5, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
            deg75, deg105 = torch.unbind(torch.index_select(
                yh5, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
            lh = c2q(deg15, deg165, ctx.ri_dim)
            hl = c2q(deg75, deg105, ctx.ri_dim)
            hh = c2q(deg45, deg135, ctx.ri_dim)
            Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
            if ll is not None and ll.shape != torch.Size([0]):
                Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
            else:
                Lo = colifilt(lh, g1b, g1a, True)
            ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        else:
            ll = rowifilt(colifilt(ll, g0b, g0a), g0b, g0a)
        

        # Level 4 inverse transform with quater shift synthesis filters
        if yh4 is not None and yh4.shape != torch.Size([0]):
            r, c = ll.shape[2:]
            r1, c1 = yh4.shape[ctx.h_dim], yh4.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]
            dev = yh4.device
            deg15, deg165 = torch.unbind(torch.index_select(
                yh4, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
            deg45, deg135 = torch.unbind(torch.index_select(
                yh4, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
            deg75, deg105 = torch.unbind(torch.index_select(
                yh4, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
            lh = c2q(deg15, deg165, ctx.ri_dim)
            hl = c2q(deg75, deg105, ctx.ri_dim)
            hh = c2q(deg45, deg135, ctx.ri_dim)
            Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
            if ll is not None and ll.shape != torch.Size([0]):
                Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
            else:
                Lo = colifilt(lh, g1b, g1a, True)
            ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        else:
            ll = rowifilt(colifilt(ll, g0b, g0a), g0b, g0a)
        

        # Level 3 inverse transform with quater shift synthesis filters
        if yh3 is not None and yh3.shape != torch.Size([0]):
            r, c = ll.shape[2:]
            r1, c1 = yh3.shape[ctx.h_dim], yh3.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]
            dev = yh3.device
            deg15, deg165 = torch.unbind(torch.index_select(
                yh3, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
            deg45, deg135 = torch.unbind(torch.index_select(
                yh3, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
            deg75, deg105 = torch.unbind(torch.index_select(
                yh3, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
            lh = c2q(deg15, deg165, ctx.ri_dim)
            hl = c2q(deg75, deg105, ctx.ri_dim)
            hh = c2q(deg45, deg135, ctx.ri_dim)
            Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
            if ll is not None and ll.shape != torch.Size([0]):
                Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
            else:
                Lo = colifilt(lh, g1b, g1a, True)
            ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        else:
            ll = rowifilt(colifilt(ll, g0b, g0a), g0b, g0a)
        

        # Level 2 inverse transform with quater shift synthesis filters
        if yh2 is not None and yh2.shape != torch.Size([0]):
            r, c = ll.shape[2:]
            r1, c1 = yh2.shape[ctx.h_dim], yh2.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]
            dev = yh2.device
            deg15, deg165 = torch.unbind(torch.index_select(
                yh2, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
            deg45, deg135 = torch.unbind(torch.index_select(
                yh2, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
            deg75, deg105 = torch.unbind(torch.index_select(
                yh2, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
            lh = c2q(deg15, deg165, ctx.ri_dim)
            hl = c2q(deg75, deg105, ctx.ri_dim)
            hh = c2q(deg45, deg135, ctx.ri_dim)
            Hi = colifilt(hh, g1b, g1a, True) + colifilt(hl, g0b, g0a)
            if ll is not None and ll.shape != torch.Size([0]):
                Lo = colifilt(lh, g1b, g1a, True) + colifilt(ll, g0b, g0a)
            else:
                Lo = colifilt(lh, g1b, g1a, True)
            ll = rowifilt(Hi, g1b, g1a, True) + rowifilt(Lo, g0b, g0a)
        else:
            ll = rowifilt(colifilt(ll, g0b, g0a), g0b, g0a)
        
        # Level 1 inverse with biorthogonal synthesis filters
        if yh1 is not None and yh1.shape != torch.Size([0]):
            r, c = ll.shape[2:]
            r1, c1 = yh1.shape[ctx.h_dim], yh1.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]
            dev = yh1.device
            deg15, deg165 = torch.unbind(torch.index_select(
                yh1, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
            deg45, deg135 = torch.unbind(torch.index_select(
                yh1, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
            deg75, deg105 = torch.unbind(torch.index_select(
                yh1, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
            lh = c2q(deg15, deg165, ctx.ri_dim)
            hl = c2q(deg75, deg105, ctx.ri_dim)
            hh = c2q(deg45, deg135, ctx.ri_dim)
            Hi = colfilter(hh, g1o) + colfilter(hl, g0o)
            if ll is not None and ll.shape != torch.Size([0]):
                Lo = colfilter(lh, g1o) + colfilter(ll, g0o)
            else:
                Lo = colfilter(lh, g1o)
            y = rowfilter(Hi, g1o) + rowfilter(Lo, g0o)
        else:
            y = rowfilter(colfilter(ll, g0o), g0o)

        return y

    @staticmethod
    def backward(ctx, grad_y):
        g0o, g1o, g0a, g0b, g1a, g1b = ctx.saved_tensors
        grad_yl = None
        grad_yh1 = None
        grad_yh2 = None
        grad_yh3 = None
        grad_yh4 = None
        grad_yh5 = None
        grad_yh6 = None
        grad_yh7 = None

        # Use the special properties of the filters to get the time reverse
        g0o_t = g0o
        g1o_t = g1o
        g0a_t = g0b
        g0b_t = g0a
        g1a_t = g1b
        g1b_t = g1a

        if True in ctx.needs_input_grad:
            # Level 1 inverse gradient - same as fwd transform
            # with time reverse biorthogonal synthesis filters
            Lo = rowfilter(grad_y, g0o_t)
            LoLo = colfilter(Lo, g0o_t)
            if ctx.needs_input_grad[1]:
                Hi = rowfilter(grad_y, g1o_t)
                LoHi = colfilter(Lo, g1o_t)
                HiLo = colfilter(Hi, g0o_t)
                HiHi = colfilter(Hi, g1o_t)
                deg15, deg165 = q2c(LoHi, ctx.ri_dim)
                deg45, deg135 = q2c(HiHi, ctx.ri_dim)
                deg75, deg105 = q2c(HiLo, ctx.ri_dim)
                grad_yh1 = torch.stack(
                    [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)

            # Level 2 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            if ctx.needs_input_grad[2]:
                Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
                LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
                HiLo = coldfilt(Hi, g0b_t, g0a_t)
                HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

                deg15, deg165 = q2c(LoHi, ctx.ri_dim)
                deg45, deg135 = q2c(HiHi, ctx.ri_dim)
                deg75, deg105 = q2c(HiLo, ctx.ri_dim)
                grad_yh2 = torch.stack(
                    [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            # Level 3 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            if ctx.needs_input_grad[3]:
                Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
                LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
                HiLo = coldfilt(Hi, g0b_t, g0a_t)
                HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

                deg15, deg165 = q2c(LoHi, ctx.ri_dim)
                deg45, deg135 = q2c(HiHi, ctx.ri_dim)
                deg75, deg105 = q2c(HiLo, ctx.ri_dim)
                grad_yh3 = torch.stack(
                    [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            # Level 4 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            if ctx.needs_input_grad[4]:
                Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
                LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
                HiLo = coldfilt(Hi, g0b_t, g0a_t)
                HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

                deg15, deg165 = q2c(LoHi, ctx.ri_dim)
                deg45, deg135 = q2c(HiHi, ctx.ri_dim)
                deg75, deg105 = q2c(HiLo, ctx.ri_dim)
                grad_yh4 = torch.stack(
                    [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            # Level 5 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            if ctx.needs_input_grad[5]:
                Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
                LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
                HiLo = coldfilt(Hi, g0b_t, g0a_t)
                HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

                deg15, deg165 = q2c(LoHi, ctx.ri_dim)
                deg45, deg135 = q2c(HiHi, ctx.ri_dim)
                deg75, deg105 = q2c(HiLo, ctx.ri_dim)
                grad_yh5 = torch.stack(
                    [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            # Level 6 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            if ctx.needs_input_grad[6]:
                Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
                LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
                HiLo = coldfilt(Hi, g0b_t, g0a_t)
                HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

                deg15, deg165 = q2c(LoHi, ctx.ri_dim)
                deg45, deg135 = q2c(HiHi, ctx.ri_dim)
                deg75, deg105 = q2c(HiLo, ctx.ri_dim)
                grad_yh6 = torch.stack(
                    [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            # Level 7 inverse gradient - same as fwd transform
            # but with time-reverse quater shift synthesis filters
            r, c = LoLo.shape[2:]
            if r % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
            if c % 4 != 0:
                LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)
            Lo = rowdfilt(LoLo, g0b_t, g0a_t)
            if ctx.needs_input_grad[7]:
                Hi = rowdfilt(LoLo, g1b_t, g1a_t, highpass=True)
                LoHi = coldfilt(Lo, g1b_t, g1a_t, highpass=True)
                HiLo = coldfilt(Hi, g0b_t, g0a_t)
                HiHi = coldfilt(Hi, g1b_t, g1a_t, highpass=True)

                deg15, deg165 = q2c(LoHi, ctx.ri_dim)
                deg45, deg135 = q2c(HiHi, ctx.ri_dim)
                deg75, deg105 = q2c(HiLo, ctx.ri_dim)
                grad_yh7 = torch.stack(
                    [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
            LoLo = coldfilt(Lo, g0b_t, g0a_t)
            if ctx.needs_input_grad[0]:
                grad_yl = LoLo

        return (grad_yl, grad_yh1, grad_yh2, grad_yh3, grad_yh4, grad_yh5, grad_yh6, grad_yh7) + (None,) * 8


class xfm7scale(Function):

    @staticmethod
    def forward(ctx, input, h0o, h1o, h0a, h0b, h1a, h1b, skip_hps, include_scale, o_dim, ri_dim):
        ctx.save_for_backward(h0o, h1o, h0a, h0b, h1a, h1b)
        ctx.o_dim = (o_dim % 6)
        ctx.ri_dim = (ri_dim % 6)
        if ctx.o_dim < ctx.ri_dim:
            ctx.ri_dim -= 1
        if ctx.o_dim >= 3 and ctx.ri_dim >= 3:
            ctx.h_dim = 2
        elif ctx.o_dim >= 4 or ctx.ri_dim >= 4:
            ctx.h_dim = 3
        else:
            ctx.h_dim = 4
        if ctx.o_dim >= 4 and ctx.ri_dim >= 4:
            ctx.w_dim = 3
        elif ctx.o_dim >=4 or ctx.ri_dim >= 4:
            ctx.w_dim = 4
        else:
            ctx.w_dim = 5

        ctx.in_shape = input.shape
        ctx.skip_hps = skip_hps
        ctx.include_scale = include_scale
        ctx.extra_rows = 0
        ctx.extra_cols = 0
        batch, ch, r, c = input.shape

        # If the row/col count of X is not divisible by 2 then we need to
        # extend X
        if r % 2 != 0:
            input = torch.cat((input, input[:,:,-1:]), dim=2)
            ctx.extra_rows = 1
        if c % 2 != 0:
            input = torch.cat((input, input[:,:,:,-1:]), dim=3)
            ctx.extra_cols = 1

        # Level 1 forward (biorthogonal analysis filters)
        Lo = rowfilter(input, h0o)
        if not ctx.skip_hps[0]:
            Hi = rowfilter(input, h1o)
            LoHi = colfilter(Lo, h1o)
            HiLo = colfilter(Hi, h0o)
            HiHi = colfilter(Hi, h1o)
            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh1 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh1 = torch.tensor([], device=input.device)
        LoLo = colfilter(Lo, h0o)
        if ctx.include_scale[0]:
            Ys1 = LoLo
        else:
            Ys1 = torch.tensor([], device=input.device)
        
        # Level 2 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        if not ctx.skip_hps[1]:
            Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
            LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
            HiLo = coldfilt(Hi, h0b, h0a)
            HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh2 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh2 = torch.tensor([], device=input.device)
        LoLo = coldfilt(Lo, h0b, h0a)
        if ctx.include_scale[1]:
            Ys2 = LoLo
        else:
            Ys2 = torch.tensor([], device=input.device)

        # Level 3 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        if not ctx.skip_hps[2]:
            Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
            LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
            HiLo = coldfilt(Hi, h0b, h0a)
            HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh3 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh3 = torch.tensor([], device=input.device)
        LoLo = coldfilt(Lo, h0b, h0a)
        if ctx.include_scale[2]:
            Ys3 = LoLo
        else:
            Ys3 = torch.tensor([], device=input.device)

        # Level 4 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        if not ctx.skip_hps[3]:
            Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
            LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
            HiLo = coldfilt(Hi, h0b, h0a)
            HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh4 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh4 = torch.tensor([], device=input.device)
        LoLo = coldfilt(Lo, h0b, h0a)
        if ctx.include_scale[3]:
            Ys4 = LoLo
        else:
            Ys4 = torch.tensor([], device=input.device)

        # Level 5 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        if not ctx.skip_hps[4]:
            Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
            LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
            HiLo = coldfilt(Hi, h0b, h0a)
            HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh5 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh5 = torch.tensor([], device=input.device)
        LoLo = coldfilt(Lo, h0b, h0a)
        if ctx.include_scale[4]:
            Ys5 = LoLo
        else:
            Ys5 = torch.tensor([], device=input.device)

        # Level 6 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        if not ctx.skip_hps[5]:
            Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
            LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
            HiLo = coldfilt(Hi, h0b, h0a)
            HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh6 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh6 = torch.tensor([], device=input.device)
        LoLo = coldfilt(Lo, h0b, h0a)
        if ctx.include_scale[5]:
            Ys6 = LoLo
        else:
            Ys6 = torch.tensor([], device=input.device)

        # Level 7 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        if not ctx.skip_hps[6]:
            Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
            LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
            HiLo = coldfilt(Hi, h0b, h0a)
            HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh7 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh7 = torch.tensor([], device=input.device)
        LoLo = coldfilt(Lo, h0b, h0a)
        if ctx.include_scale[6]:
            Ys7 = LoLo
        else:
            Ys7 = torch.tensor([], device=input.device)

        Yl = LoLo
        return Ys1, Ys2, Ys3, Ys4, Ys5, Ys6, Ys7, Yh1, Yh2, Yh3, Yh4, Yh5, Yh6, Yh7

    @staticmethod
    def backward(ctx, grad_Ys1, grad_Ys2, grad_Ys3, grad_Ys4, grad_Ys5, grad_Ys6, grad_Ys7, grad_Yh1, grad_Yh2, grad_Yh3, grad_Yh4, grad_Yh5, grad_Yh6, grad_Yh7):
        h0o, h1o, h0a, h0b, h1a, h1b = ctx.saved_tensors
        in_shape = ctx.in_shape
        grad_input = None
        # Use the special properties of the filters to get the time reverse
        h0o_t = h0o
        h1o_t = h1o
        h0a_t = h0b
        h0b_t = h0a
        h1a_t = h1b
        h1b_t = h1a

        if True in ctx.needs_input_grad:
            ll = grad_Ys7
            
            # Level 7 backward (time reversed quater shift analysis filters)
            if not ctx.skip_hps[6]:
                dev = grad_Yh7.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh7, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh7, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh7, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
                Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
                ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            else:
                ll = rowifilt(colifilt(Lo, h0b_t, h0a_t), h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh6.shape[ctx.h_dim], grad_Yh6.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]
            if ctx.include_scale[5]:
                ll = (ll + grad_Ys6)/2

            # Level 6 backward (time reversed quater shift analysis filters)
            if not ctx.skip_hps[5]:
                dev = grad_Yh6.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh6, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh6, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh6, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
                Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
                ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            else:
                ll = rowifilt(colifilt(Lo, h0b_t, h0a_t), h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh5.shape[ctx.h_dim], grad_Yh5.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]
            if ctx.include_scale[4]:
                ll = (ll + grad_Ys5)/2

            # Level 5 backward (time reversed quater shift analysis filters)
            if not ctx.skip_hps[4]:
                dev = grad_Yh5.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh5, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh5, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh5, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
                Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
                ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            else:
                ll = rowifilt(colifilt(Lo, h0b_t, h0a_t), h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh4.shape[ctx.h_dim], grad_Yh4.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]
            if ctx.include_scale[3]:
                ll = (ll + grad_Ys4)/2

            # Level 4 backward (time reversed quater shift analysis filters)
            if not ctx.skip_hps[3]:
                dev = grad_Yh4.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh4, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh4, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh4, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
                Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
                ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            else:
                ll = rowifilt(colifilt(Lo, h0b_t, h0a_t), h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh3.shape[ctx.h_dim], grad_Yh3.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]
            if ctx.include_scale[2]:
                ll = (ll + grad_Ys3)/2

            # Level 3 backward (time reversed quater shift analysis filters)
            if not ctx.skip_hps[2]:
                dev = grad_Yh3.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh3, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh3, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh3, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
                Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
                ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            else:
                ll = rowifilt(colifilt(Lo, h0b_t, h0a_t), h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh2.shape[ctx.h_dim], grad_Yh2.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]
            if ctx.include_scale[1]:
                ll = (ll + grad_Ys2)/2

            # Level 2 backward (time reversed quater shift analysis filters)
            if not ctx.skip_hps[1]:
                dev = grad_Yh2.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh2, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh2, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh2, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
                Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
                ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            else:
                ll = rowifilt(colifilt(Lo, h0b_t, h0a_t), h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh1.shape[ctx.h_dim], grad_Yh1.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]
            if ctx.include_scale[0]:
                ll = (ll + grad_Ys1)/2

            # Level 1 backward (time reversed biorthogonal analysis filters)
            if not ctx.skip_hps[0]:
                dev = grad_Yh1.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh1, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh1, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh1, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colfilter(hh, h1o_t) + colfilter(hl, h0o_t)
                Lo = colfilter(lh, h1o_t) + colfilter(ll, h0o_t)
                grad_input = rowfilter(Hi, h1o_t) + rowfilter(Lo, h0o_t)
            else:
                grad_input = rowfilter(colfilter(ll, h0o_t), h0o_t)
            if ctx.extra_rows:
                grad_input = grad_input[:,:,:-1]
            if ctx.extra_cols:
                grad_input = grad_input[:,:,:,:-1]
            

        return (grad_input,) + (None,) * 10


class xfm7(Function):

    @staticmethod
    def forward(ctx, input, h0o, h1o, h0a, h0b, h1a, h1b, skip_hps, include_scale, o_dim, ri_dim):
        ctx.save_for_backward(h0o, h1o, h0a, h0b, h1a, h1b)
        ctx.o_dim = (o_dim % 6)
        ctx.ri_dim = (ri_dim % 6)
        if ctx.o_dim < ctx.ri_dim:
            ctx.ri_dim -= 1
        if ctx.o_dim >= 3 and ctx.ri_dim >= 3:
            ctx.h_dim = 2
        elif ctx.o_dim >= 4 or ctx.ri_dim >= 4:
            ctx.h_dim = 3
        else:
            ctx.h_dim = 4
        if ctx.o_dim >= 4 and ctx.ri_dim >= 4:
            ctx.w_dim = 3
        elif ctx.o_dim >=4 or ctx.ri_dim >= 4:
            ctx.w_dim = 4
        else:
            ctx.w_dim = 5

        ctx.in_shape = input.shape
        ctx.skip_hps = skip_hps
        ctx.include_scale = include_scale
        ctx.extra_rows = 0
        ctx.extra_cols = 0
        batch, ch, r, c = input.shape

        # If the row/col count of X is not divisible by 2 then we need to
        # extend X
        if r % 2 != 0:
            input = torch.cat((input, input[:,:,-1:]), dim=2)
            ctx.extra_rows = 1
        if c % 2 != 0:
            input = torch.cat((input, input[:,:,:,-1:]), dim=3)
            ctx.extra_cols = 1

        # Level 1 forward (biorthogonal analysis filters)
        Lo = rowfilter(input, h0o)
        if not ctx.skip_hps[0]:
            Hi = rowfilter(input, h1o)
            LoHi = colfilter(Lo, h1o)
            HiLo = colfilter(Hi, h0o)
            HiHi = colfilter(Hi, h1o)
            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh1 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh1 = torch.tensor([], device=input.device)
        LoLo = colfilter(Lo, h0o)
        if ctx.include_scale[0]:
            Ys1 = LoLo
        else:
            Ys1 = torch.tensor([], device=input.device)
        
        # Level 2 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        if not ctx.skip_hps[1]:
            Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
            LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
            HiLo = coldfilt(Hi, h0b, h0a)
            HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh2 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh2 = torch.tensor([], device=input.device)
        LoLo = coldfilt(Lo, h0b, h0a)
        if ctx.include_scale[1]:
            Ys2 = LoLo
        else:
            Ys2 = torch.tensor([], device=input.device)

        # Level 3 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        if not ctx.skip_hps[2]:
            Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
            LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
            HiLo = coldfilt(Hi, h0b, h0a)
            HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh3 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh3 = torch.tensor([], device=input.device)
        LoLo = coldfilt(Lo, h0b, h0a)
        if ctx.include_scale[2]:
            Ys3 = LoLo
        else:
            Ys3 = torch.tensor([], device=input.device)

        # Level 4 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        if not ctx.skip_hps[3]:
            Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
            LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
            HiLo = coldfilt(Hi, h0b, h0a)
            HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh4 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh4 = torch.tensor([], device=input.device)
        LoLo = coldfilt(Lo, h0b, h0a)
        if ctx.include_scale[3]:
            Ys4 = LoLo
        else:
            Ys4 = torch.tensor([], device=input.device)

        # Level 5 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        if not ctx.skip_hps[4]:
            Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
            LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
            HiLo = coldfilt(Hi, h0b, h0a)
            HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh5 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh5 = torch.tensor([], device=input.device)
        LoLo = coldfilt(Lo, h0b, h0a)
        if ctx.include_scale[4]:
            Ys5 = LoLo
        else:
            Ys5 = torch.tensor([], device=input.device)

        # Level 6 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        if not ctx.skip_hps[5]:
            Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
            LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
            HiLo = coldfilt(Hi, h0b, h0a)
            HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh6 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh6 = torch.tensor([], device=input.device)
        LoLo = coldfilt(Lo, h0b, h0a)
        if ctx.include_scale[5]:
            Ys6 = LoLo
        else:
            Ys6 = torch.tensor([], device=input.device)

        # Level 7 forward (quater shift analysis filters)
        r, c = LoLo.shape[2:]
        if r % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,0:1], LoLo, LoLo[:,:,-1:]), dim=2)
        if c % 4 != 0:
            LoLo = torch.cat((LoLo[:,:,:,0:1], LoLo, LoLo[:,:,:,-1:]), dim=3)

        Lo = rowdfilt(LoLo, h0b, h0a)
        if not ctx.skip_hps[6]:
            Hi = rowdfilt(LoLo, h1b, h1a, highpass=True)
            LoHi = coldfilt(Lo, h1b, h1a, highpass=True)
            HiLo = coldfilt(Hi, h0b, h0a)
            HiHi = coldfilt(Hi, h1b, h1a, highpass=True)

            deg15, deg165 = q2c(LoHi, ctx.ri_dim)
            deg45, deg135 = q2c(HiHi, ctx.ri_dim)
            deg75, deg105 = q2c(HiLo, ctx.ri_dim)
            Yh7 = torch.stack(
                [deg15, deg45, deg75, deg105, deg135, deg165], dim=ctx.o_dim)
        else:
            Yh7 = torch.tensor([], device=input.device)
        LoLo = coldfilt(Lo, h0b, h0a)
        if ctx.include_scale[6]:
            Ys7 = LoLo
        else:
            Ys7 = torch.tensor([], device=input.device)

        Yl = LoLo
        return Yl, Yh1, Yh2, Yh3, Yh4, Yh5, Yh6, Yh7

    @staticmethod
    def backward(ctx, grad_LoLo, grad_Yh1, grad_Yh2, grad_Yh3, grad_Yh4, grad_Yh5, grad_Yh6, grad_Yh7):
        h0o, h1o, h0a, h0b, h1a, h1b = ctx.saved_tensors
        in_shape = ctx.in_shape
        grad_input = None
        # Use the special properties of the filters to get the time reverse
        h0o_t = h0o
        h1o_t = h1o
        h0a_t = h0b
        h0b_t = h0a
        h1a_t = h1b
        h1b_t = h1a

        if True in ctx.needs_input_grad:
            ll = grad_LoLo
            
            # Level 7 backward (time reversed quater shift analysis filters)
            if not ctx.skip_hps[6]:
                dev = grad_Yh7.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh7, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh7, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh7, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
                Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
                ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            else:
                ll = rowifilt(colifilt(Lo, h0b_t, h0a_t), h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh6.shape[ctx.h_dim], grad_Yh6.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 6 backward (time reversed quater shift analysis filters)
            if not ctx.skip_hps[5]:
                dev = grad_Yh6.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh6, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh6, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh6, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
                Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
                ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            else:
                ll = rowifilt(colifilt(Lo, h0b_t, h0a_t), h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh5.shape[ctx.h_dim], grad_Yh5.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 5 backward (time reversed quater shift analysis filters)
            if not ctx.skip_hps[4]:
                dev = grad_Yh5.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh5, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh5, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh5, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
                Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
                ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            else:
                ll = rowifilt(colifilt(Lo, h0b_t, h0a_t), h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh4.shape[ctx.h_dim], grad_Yh4.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 4 backward (time reversed quater shift analysis filters)
            if not ctx.skip_hps[3]:
                dev = grad_Yh4.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh4, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh4, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh4, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
                Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
                ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            else:
                ll = rowifilt(colifilt(Lo, h0b_t, h0a_t), h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh3.shape[ctx.h_dim], grad_Yh3.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 3 backward (time reversed quater shift analysis filters)
            if not ctx.skip_hps[2]:
                dev = grad_Yh3.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh3, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh3, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh3, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
                Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
                ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            else:
                ll = rowifilt(colifilt(Lo, h0b_t, h0a_t), h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh2.shape[ctx.h_dim], grad_Yh2.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 2 backward (time reversed quater shift analysis filters)
            if not ctx.skip_hps[1]:
                dev = grad_Yh2.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh2, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh2, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh2, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colifilt(hh, h1b_t, h1a_t, True) + colifilt(hl, h0b_t, h0a_t)
                Lo = colifilt(lh, h1b_t, h1a_t, True) + colifilt(ll, h0b_t, h0a_t)
                ll = rowifilt(Hi, h1b_t, h1a_t, True) + rowifilt(Lo, h0b_t, h0a_t)
            else:
                ll = rowifilt(colifilt(Lo, h0b_t, h0a_t), h0b_t, h0a_t)
            r, c = ll.shape[2:]
            r1, c1 = grad_Yh1.shape[ctx.h_dim], grad_Yh1.shape[ctx.w_dim]
            if r != r1 * 2:
                ll = ll[:,:,1:-1]
            if c != c1 * 2:
                ll = ll[:,:,:,1:-1]

            # Level 1 backward (time reversed biorthogonal analysis filters)
            if not ctx.skip_hps[0]:
                dev = grad_Yh1.device
                deg15, deg165 = torch.unbind(torch.index_select(
                    grad_Yh1, ctx.o_dim, torch.tensor([0, 5], device=dev)), dim=ctx.o_dim)
                deg45, deg135 = torch.unbind(torch.index_select(
                    grad_Yh1, ctx.o_dim, torch.tensor([1, 4], device=dev)), dim=ctx.o_dim)
                deg75, deg105 = torch.unbind(torch.index_select(
                    grad_Yh1, ctx.o_dim, torch.tensor([2, 3], device=dev)), dim=ctx.o_dim)
                lh = c2q(deg15, deg165, ctx.ri_dim)
                hl = c2q(deg75, deg105, ctx.ri_dim)
                hh = c2q(deg45, deg135, ctx.ri_dim)
                Hi = colfilter(hh, h1o_t) + colfilter(hl, h0o_t)
                Lo = colfilter(lh, h1o_t) + colfilter(ll, h0o_t)
                grad_input = rowfilter(Hi, h1o_t) + rowfilter(Lo, h0o_t)
            else:
                grad_input = rowfilter(colfilter(ll, h0o_t), h0o_t)
            if ctx.extra_rows:
                grad_input = grad_input[:,:,:-1]
            if ctx.extra_cols:
                grad_input = grad_input[:,:,:,:-1]
            

        return (grad_input,) + (None,) * 10

